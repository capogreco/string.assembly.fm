<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal WebRTC Data Channel Test</title>
    <style>
        body {
            font-family: monospace;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #111;
            color: #eee;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            border: 1px solid #444;
            padding: 15px;
            background: #222;
            display: flex;
            flex-direction: column;
        }
        h2 {
            margin-top: 0;
            color: #ff0;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        button {
            background: #00A86B;
            color: #fff;
            border: none;
            padding: 10px 15px;
            margin: 5px 0;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
            flex-shrink: 0;
        }
        button:hover {
            background: #00905A;
        }
        button:disabled {
            background: #555;
            color: #999;
            cursor: not-allowed;
        }
        textarea {
            width: 100%;
            height: 150px;
            background: #000;
            color: #0f0;
            border: 1px solid #333;
            margin-top: 10px;
            font-family: monospace;
            flex-grow: 1;
        }
        input[type="text"] {
            width: calc(100% - 10px);
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 5px;
            margin-bottom: 10px;
        }
        .log-area {
            background: #000;
            border: 1px solid #333;
            padding: 10px;
            height: 300px;
            overflow-y: auto;
            font-size: 12px;
            flex-grow: 1;
        }
        .log-area div {
            margin-bottom: 5px;
            border-bottom: 1px dotted #333;
            padding-bottom: 5px;
        }
        .status {
            margin-top: 10px;
            padding: 8px;
            background: #333;
            border-left: 4px solid #ff0;
        }
    </style>
</head>
<body>
    <h1>Minimal WebRTC Data Channel Test</h1>
    <p>Use this to test the core WebRTC connection. Open this page in two separate browser windows (ideally on different networks). One acts as the "Offerer" (like the synth) and the other as the "Answerer" (like the controller).</p>
    <div class="container">
        <div class="panel">
            <h2>Controls</h2>
            <div>Your ID: <b id="my-id">-</b></div>
            <input type="text" id="peer-id-input" placeholder="Enter Peer's ID">
            <button id="start-btn">1. Start & Connect WebSocket</button>
            <button id="initiate-offer-btn" disabled>2. Initiate Offer</button>
            <div class="status">Connection State: <b id="connection-state">NEW</b></div>
            <div class="status">ICE State: <b id="ice-state">NEW</b></div>
            <div class="status">Data Channel: <b id="datachannel-state">CLOSED</b></div>
        </div>
        <div class="panel">
            <h2>Data Channel</h2>
            <input type="text" id="message-input" placeholder="Type a message..." disabled>
            <button id="send-message-btn" disabled>Send Message</button>
            <p>Received Messages:</p>
            <div id="messages" class="log-area"></div>
        </div>
    </div>
    <div class="panel">
        <h2>Event Log</h2>
        <div id="event-log" class="log-area"></div>
    </div>

    <script>
        const startBtn = document.getElementById('start-btn');
        const initiateOfferBtn = document.getElementById('initiate-offer-btn');
        const sendMessageBtn = document.getElementById('send-message-btn');

        const myIdEl = document.getElementById('my-id');
        const peerIdInput = document.getElementById('peer-id-input');
        const messageInput = document.getElementById('message-input');

        const eventLog = document.getElementById('event-log');
        const messagesLog = document.getElementById('messages');
        const connectionStateEl = document.getElementById('connection-state');
        const iceStateEl = document.getElementById('ice-state');
        const datachannelStateEl = document.getElementById('datachannel-state');

        let pc;
        let dataChannel;
        let ws;
        let clientId;
        let iceServers = [{ urls: "stun:stun.l.google.com:19302" }];

        function log(message, ...args) {
            console.log(message, ...args);
            const entry = document.createElement('div');
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message} ${args.length > 0 ? JSON.stringify(args, null, 2) : ''}`;
            eventLog.appendChild(entry);
            eventLog.scrollTop = eventLog.scrollHeight;
        }

        async function fetchIceServers() {
            try {
                const response = await fetch('/ice-servers');
                const data = await response.json();
                if (data.ice_servers && data.ice_servers.length > 0) {
                    iceServers = data.ice_servers;
                    log('✅ Successfully fetched ICE servers from server.');
                } else {
                    log('⚠️ Could not fetch ICE servers, using default STUN.');
                }
            } catch (error) {
                log('❌ Error fetching ICE servers:', error.message);
            }
        }

        function connectWebSocket() {
            log('🔌 Connecting to WebSocket server...');
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

            ws.onopen = () => {
                log('✅ WebSocket connection established.');
                startBtn.disabled = true;
                initiateOfferBtn.disabled = false;
            };

            ws.onmessage = async (event) => {
                const msg = JSON.parse(event.data);
                if (msg.target && msg.target !== clientId) return;

                log(`⬇️ Received WebSocket message:`, msg.type);

                switch (msg.type) {
                    case 'offer':
                        await handleOffer(msg);
                        break;
                    case 'answer':
                        await handleAnswer(msg);
                        break;
                    case 'ice-candidate':
                        await handleIceCandidate(msg);
                        break;
                }
            };

            ws.onclose = () => {
                log('❌ WebSocket connection closed.');
                startBtn.disabled = false;
                initiateOfferBtn.disabled = true;
            };

            ws.onerror = (error) => {
                log('❌ WebSocket error:', error);
            };
        }

        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                log(`⬆️ Sending WebSocket message:`, message.type);
                ws.send(JSON.stringify(message));
            }
        }

        function createPeerConnection() {
            log('Creating new RTCPeerConnection...');
            pc = new RTCPeerConnection({ iceServers });

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    sendMessage({
                        type: 'ice-candidate',
                        source: clientId,
                        target: peerIdInput.value,
                        data: event.candidate
                    });
                } else {
                    log('ICE gathering complete.');
                }
            };

            pc.onconnectionstatechange = () => {
                log(`Connection state changed: ${pc.connectionState}`);
                connectionStateEl.textContent = pc.connectionState.toUpperCase();
            };

            pc.oniceconnectionstatechange = () => {
                log(`ICE connection state changed: ${pc.iceConnectionState}`);
                iceStateEl.textContent = pc.iceConnectionState.toUpperCase();
            };

            pc.ondatachannel = (event) => {
                log('🤝 Data channel received!');
                dataChannel = event.channel;
                setupDataChannel();
            };
        }

        function setupDataChannel() {
            log('Setting up data channel listeners...');
            dataChannel.onopen = () => {
                log('✅ Data channel OPEN!');
                datachannelStateEl.textContent = dataChannel.readyState.toUpperCase();
                messageInput.disabled = false;
                sendMessageBtn.disabled = false;
            };

            dataChannel.onclose = () => {
                log('❌ Data channel CLOSED.');
                datachannelStateEl.textContent = dataChannel.readyState.toUpperCase();
                messageInput.disabled = true;
                sendMessageBtn.disabled = true;
            };

            dataChannel.onmessage = (event) => {
                log(`💬 Message received: "${event.data}"`);
                const entry = document.createElement('div');
                entry.textContent = `[Peer]: ${event.data}`;
                messagesLog.appendChild(entry);
                messagesLog.scrollTop = messagesLog.scrollHeight;
            };
        }

        async function startOffer() {
            if (!peerIdInput.value) {
                alert('Please enter a Peer ID.');
                return;
            }
            log('🎬 Initiating offer...');
            initiateOfferBtn.disabled = true;

            createPeerConnection();

            log('Creating data channel...');
            dataChannel = pc.createDataChannel('main-data-channel', { ordered: true });
            setupDataChannel();

            log('Creating offer...');
            const offer = await pc.createOffer();
            log('Setting local description...');
            await pc.setLocalDescription(offer);

            sendMessage({
                type: 'offer',
                source: clientId,
                target: peerIdInput.value,
                data: offer
            });
        }

        async function handleOffer(msg) {
            log('Received an offer. Creating peer connection...');
            peerIdInput.value = msg.source;
            createPeerConnection();

            log('Setting remote description...');
            await pc.setRemoteDescription(new RTCSessionDescription(msg.data));

            log('Creating answer...');
            const answer = await pc.createAnswer();
            log('Setting local description...');
            await pc.setLocalDescription(answer);

            sendMessage({
                type: 'answer',
                source: clientId,
                target: msg.source,
                data: answer
            });
        }

        async function handleAnswer(msg) {
            log('Received an answer. Setting remote description...');
            if (pc) {
                await pc.setRemoteDescription(new RTCSessionDescription(msg.data));
            } else {
                log('❌ PeerConnection not initialized. Cannot handle answer.');
            }
        }

        async function handleIceCandidate(msg) {
            log('Received an ICE candidate. Adding candidate...');
            if (pc) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(msg.data));
                } catch (e) {
                    log('❌ Error adding received ICE candidate:', e);
                }
            } else {
                log('❌ PeerConnection not initialized. Cannot handle ICE candidate.');
            }
        }

        startBtn.addEventListener('click', async () => {
            clientId = `peer-${Math.random().toString(36).substr(2, 9)}`;
            myIdEl.textContent = clientId;
            await fetchIceServers();
            connectWebSocket();
        });

        initiateOfferBtn.addEventListener('click', startOffer);

        sendMessageBtn.addEventListener('click', () => {
            const message = messageInput.value;
            if (message && dataChannel.readyState === 'open') {
                log(`💬 Sending message: "${message}"`);
                dataChannel.send(message);
                const entry = document.createElement('div');
                entry.textContent = `[Me]: ${message}`;
                messagesLog.appendChild(entry);
                messagesLog.scrollTop = messagesLog.scrollHeight;
                messageInput.value = '';
            }
        });

    </script>
</body>
</html>
