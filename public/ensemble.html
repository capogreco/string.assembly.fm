<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>String Assembly FM - Multi-Synth Test Client</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
                min-height: 100vh;
                color: white;
                padding: 20px;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
            }

            h1 {
                text-align: center;
                margin-bottom: 30px;
                text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            }

            .controls {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 30px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .control-row {
                display: flex;
                gap: 20px;
                align-items: center;
                margin-bottom: 15px;
            }

            button {
                padding: 10px 20px;
                border: none;
                border-radius: 6px;
                background: #3498db;
                color: white;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            button:hover {
                background: #2980b9;
                transform: translateY(-2px);
            }

            button:disabled {
                background: #7f8c8d;
                cursor: not-allowed;
                transform: none;
            }

            #start_calibration,
            #join_instrument {
                display: block;
                margin: 30px auto;
                padding: 15px 30px;
                background: #c44;
                font-size: 16px;
                animation: pulse 2s infinite;
            }

            #start_calibration:hover,
            #join_instrument:hover {
                background: #d55;
            }

            #start_calibration:disabled,
            #join_instrument:disabled {
                animation: none;
                background: #444;
                opacity: 0.5;
            }

            @keyframes pulse {
                0% {
                    opacity: 1;
                }
                50% {
                    opacity: 0.7;
                }
                100% {
                    opacity: 1;
                }
            }

            #calibration_phase,
            #join_phase {
                text-align: center;
                margin: 20px 0;
                padding: 20px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 8px;
            }

            .synth-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 20px;
            }

            .synth-unit {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                transition: all 0.3s ease;
            }

            .synth-unit.active {
                border-color: #3498db;
                box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
            }

            .synth-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .synth-id {
                font-weight: bold;
                font-size: 1.1em;
            }

            .status-dot {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: #e74c3c;
            }

            .status-dot.connected {
                background: #2ecc71;
            }

            .note-display {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                padding: 10px;
                margin-bottom: 10px;
                font-family: monospace;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.2em;
            }

            .expression-display {
                font-size: 0.9em;
                color: rgba(255, 255, 255, 0.8);
                margin-bottom: 10px;
            }

            .level-meter {
                height: 100px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                position: relative;
                overflow: hidden;
                margin-bottom: 10px;
            }

            .level-bar {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(to top, #2ecc71, #f1c40f, #e74c3c);
                transition: height 0.1s ease;
            }

            .pan-control {
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 0.9em;
            }

            .pan-slider {
                flex: 1;
            }

            .log-area {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                padding: 15px;
                margin-top: 30px;
                font-family: monospace;
                font-size: 0.9em;
                max-height: 200px;
                overflow-y: auto;
            }

            .log-entry {
                margin-bottom: 5px;
                opacity: 0.8;
            }

            .log-entry.error {
                color: #e74c3c;
            }

            .log-entry.info {
                color: #3498db;
            }

            input[type="number"] {
                width: 60px;
                padding: 5px;
                border: 1px solid rgba(255, 255, 255, 0.3);
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border-radius: 4px;
            }

            input[type="range"] {
                width: 100%;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>ðŸŽ¼ Multi-Synth Test Ensemble</h1>

            <div id="calibration_phase">
                <h3>Volume Calibration</h3>
                <p>Calibrate the ensemble volume level.</p>
                <button id="start_calibration">Calibrate Volume</button>
            </div>

            <div id="join_phase" style="display: none">
                <p>
                    Pink noise playing at reference level. Adjust your device
                    volume to a comfortable level, then:
                </p>
                <button id="join_instrument">Join Instrument</button>
            </div>

            <div class="controls">
                <div class="control-row">
                    <label>Number of Synths:</label>
                    <input
                        type="number"
                        id="synth-count"
                        value="6"
                        min="1"
                        max="12"
                        readonly
                    />
                </div>
                <div class="control-row">
                    <label>Master Volume:</label>
                    <input
                        type="range"
                        id="master-volume"
                        min="0"
                        max="1"
                        step="0.01"
                        value="0.7"
                    />
                    <span id="volume-display">70%</span>
                </div>
            </div>

            <div class="synth-grid" id="synth-grid">
                <!-- Synth units will be generated here -->
            </div>

            <div class="log-area" id="log-area">
                <div class="log-entry info">
                    Multi-synth test client ready. Click Initialize to begin.
                </div>
            </div>
        </div>

        <script type="module">
            // Import SynthCore
            import { SynthCore } from "../src/synth/synth-core.js";

            // Global state
            let audioContext = null;
            let synths = [];
            let controllerConnection = null;
            let masterGain = null;
            let isInitialized = false;
            let inCalibrationMode = false;

            // Real WebRTC configuration
            const rtcConfig = {
                iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
            };

            // Wrapper class for SynthCore in ensemble
            class TestSynth {
                constructor(id, index, totalSynths) {
                    this.id = id;
                    this.index = index;
                    this.element = null;
                    this.noteDisplay = null;
                    this.expressionDisplay = null;
                    this.levelMeter = null;
                    this.panControl = null;

                    // State
                    this.currentNote = null;
                    this.currentExpression = null;
                    this.isActive = false;
                    this.currentProgram = null;

                    // Banking
                    this.synthBanks = new Map();

                    // WebRTC connections (will be set up later)
                    this.ws = null;
                    this.controllers = new Map();

                    // Calculate pan position
                    this.panPosition =
                        totalSynths === 1
                            ? 0
                            : (index / (totalSynths - 1)) * 2 - 1;

                    // Create SynthCore instance
                    this.synthCore = new SynthCore(id, { enableLogging: true });
                }

                async initialize(audioCtx, destination) {
                    // Create additional nodes for ensemble-specific features
                    this.panner = audioCtx.createStereoPanner();
                    this.panner.pan.value = this.panPosition;

                    this.analyser = audioCtx.createAnalyser();
                    this.analyser.fftSize = 256;

                    // Initialize SynthCore
                    await this.synthCore.initialize(audioCtx, this.analyser);

                    // Connect SynthCore output through our panner to destination
                    this.analyser.connect(this.panner);
                    this.panner.connect(destination);

                    // Ensure we have the analyser reference for level meters
                    this.analyser =
                        this.synthCore.analyserNode || this.analyser;

                    this.audioInitialized = true;
                    log(
                        `[${this.id}] SynthCore initialized with panning`,
                        "info",
                    );
                }

                createElements(container) {
                    this.element = this.createUI();
                    container.appendChild(this.element);
                }

                async ensureAudioInitialized(audioCtx, destination) {
                    if (!this.audioInitialized) {
                        await this.initialize(audioCtx, destination);
                    }
                }

                handleParamMessage(event) {
                    const data =
                        typeof event.data === "string"
                            ? JSON.parse(event.data)
                            : event.data;

                    log(
                        `[${this.id}] Received param message: ${data.type}`,
                        "info",
                    );

                    if (data.type === "program") {
                        log(
                            `[${this.id}] Received program message with transition: ${JSON.stringify(data.transition)}`,
                            "info",
                        );
                        this.applyProgram(data.program, data.transition);
                    } else if (data.type === "setTransitionConfig") {
                        // Forward transition config to worklet
                        if (this.bowedString) {
                            this.bowedString.port.postMessage({
                                type: "setTransitionConfig",
                                config: data.config,
                            });
                            log(
                                `[${this.id}] Applied transition config: ${JSON.stringify(data.config)}`,
                                "info",
                            );
                        }
                    } else if (data.type === "ping") {
                        if (
                            this.paramChannel &&
                            this.paramChannel.readyState === "open"
                        ) {
                            this.paramChannel.send(
                                JSON.stringify({
                                    type: "pong",
                                    timestamp: data.timestamp,
                                    state: {
                                        audio_enabled: true,
                                        joined: this.isActive,
                                    },
                                }),
                            );
                        }
                    }
                }

                handleCommandMessage(event) {
                    const data =
                        typeof event.data === "string"
                            ? JSON.parse(event.data)
                            : event.data;

                    if (data.type === "command") {
                        if (data.name === "power") {
                            this.setPower(data.value);
                        } else if (data.name === "save") {
                            this.handleSaveCommand(data.bank || data.value);
                        } else if (data.name === "load") {
                            this.handleLoadCommand(
                                data.bank,
                                data.fallbackProgram,
                            );
                        }
                    }
                }

                applyProgram(program, transition) {
                    log(
                        `[${this.id}] Applying program via SynthCore: freq=${program.fundamentalFrequency?.toFixed(1)}Hz${transition ? " with transition" : ""}`,
                        "info",
                    );

                    if (transition) {
                        log(
                            `[${this.id}] Transition data: delay=${transition.delay?.toFixed(3)}s, duration=${transition.duration?.toFixed(3)}s`,
                            "info",
                        );
                    }

                    // Store current program for banking
                    this.currentProgram = program;

                    // Update display
                    if (program.fundamentalFrequency) {
                        const noteInfo = this.frequencyToNote(
                            program.fundamentalFrequency,
                        );
                        this.currentNote = noteInfo.note;
                        this.noteDisplay.textContent = noteInfo.note;

                        // Update expression display with specific expression
                        if (program.vibratoEnabled) {
                            this.currentExpression = "Vibrato";
                        } else if (program.tremoloEnabled) {
                            this.currentExpression = "Tremolo";
                        } else if (program.trillEnabled) {
                            this.currentExpression = "Trill";
                        } else {
                            this.currentExpression = "None";
                        }
                        this.expressionDisplay.textContent =
                            this.currentExpression;
                    } else {
                        this.noteDisplay.textContent = "-";
                        this.expressionDisplay.textContent = "None";
                    }

                    // Mark as active
                    this.isActive = true;

                    // Delegate to SynthCore for all synthesis logic
                    if (this.synthCore && this.synthCore.isInitialized) {
                        this.synthCore.applyProgram(program, transition);
                    } else {
                        log(
                            `[${this.id}] SynthCore not ready for program`,
                            "warn",
                        );
                    }

                    this.element.classList.add("active");
                    log(
                        `[${this.id}] Program applied and synth UI activated`,
                        "info",
                    );
                } // End of applyProgram method

                setPower(on) {
                    this.isActive = on;

                    if (this.synthCore) {
                        this.synthCore.setPower(on);
                    }

                    if (on) {
                        this.element.classList.add("active");
                    } else {
                        this.element.classList.remove("active");
                    }

                    log(`[${this.id}] Power: ${on ? "ON" : "OFF"}`, "info");
                }

                handleSaveCommand(bankId) {
                    if (this.synthCore) {
                        this.synthCore.saveToBank(bankId);
                        log(
                            `[${this.id}] Saved to bank ${bankId} via SynthCore`,
                            "info",
                        );
                    } else {
                        log(
                            `[${this.id}] SynthCore not available for saving`,
                            "error",
                        );
                    }
                }

                handleLoadCommand(bankId, fallbackProgram) {
                    if (this.synthCore) {
                        const success = this.synthCore.loadFromBank(
                            bankId,
                            fallbackProgram,
                        );
                        if (!success && fallbackProgram) {
                            this.applyProgram(fallbackProgram);
                        }
                    } else if (this.synthBanks.has(bankId)) {
                        // This synth has saved state - restore exact values
                        const savedProgram = this.synthBanks.get(bankId);
                        log(
                            `[${this.id}] Loading saved parameters from bank ${bankId}`,
                            "info",
                        );
                        this.applyProgram(savedProgram);
                    } else if (fallbackProgram) {
                        // New synth - use fallback program from controller
                        log(
                            `[${this.id}] New synth using fallback program for bank ${bankId}`,
                            "info",
                        );
                        this.applyProgram(fallbackProgram);
                    } else {
                        log(
                            `[${this.id}] No saved program for bank ${bankId} and no fallback provided`,
                            "warn",
                        );
                    }
                }

                loadSynthBanksFromStorage() {
                    try {
                        const saved = localStorage.getItem(
                            `synth-banks-${this.id}`,
                        );
                        if (saved) {
                            const banksData = JSON.parse(saved);
                            Object.entries(banksData).forEach(
                                ([bankId, program]) => {
                                    this.synthBanks.set(
                                        parseInt(bankId),
                                        program,
                                    );
                                },
                            );
                            log(
                                `[${this.id}] Loaded ${this.synthBanks.size} saved banks from storage`,
                                "info",
                            );
                        }
                    } catch (e) {
                        log(
                            `[${this.id}] Failed to load banks from storage: ${e.message}`,
                            "error",
                        );
                    }
                }

                frequencyToNote(freq) {
                    const A4 = 440;
                    const semitones = Math.round(12 * Math.log2(freq / A4));
                    const noteNames = [
                        "C",
                        "C#",
                        "D",
                        "D#",
                        "E",
                        "F",
                        "F#",
                        "G",
                        "G#",
                        "A",
                        "A#",
                        "B",
                    ];
                    const octave = Math.floor((semitones + 57) / 12);
                    const noteIndex = (semitones + 69) % 12;
                    return { note: noteNames[noteIndex] + octave, semitones };
                }

                updateLevel() {
                    if (!this.levelMeter) return;

                    // Use SynthCore's getAudioLevel method if available
                    let level = 0;
                    if (this.synthCore && this.synthCore.isInitialized) {
                        level = this.synthCore.getAudioLevel();
                    } else if (this.analyser) {
                        // Fallback to manual calculation
                        const dataArray = new Uint8Array(
                            this.analyser.frequencyBinCount,
                        );
                        this.analyser.getByteFrequencyData(dataArray);

                        let sum = 0;
                        for (let i = 0; i < dataArray.length; i++) {
                            sum += dataArray[i];
                        }
                        level = sum / dataArray.length / 255;
                    }

                    this.levelMeter.style.height = `${level * 100}%`;
                }

                createUI() {
                    const unit = document.createElement("div");
                    unit.className = "synth-unit";

                    const header = document.createElement("div");
                    header.className = "synth-header";

                    const synthId = document.createElement("span");
                    synthId.className = "synth-id";
                    synthId.textContent = this.id;

                    const statusDot = document.createElement("div");
                    statusDot.className = "status-dot connected";

                    header.appendChild(synthId);
                    header.appendChild(statusDot);

                    const noteDisplay = document.createElement("div");
                    noteDisplay.className = "note-display";
                    noteDisplay.textContent = "--";

                    const expressionDisplay = document.createElement("div");
                    expressionDisplay.className = "expression-display";
                    expressionDisplay.textContent = "Expression: None";

                    const levelMeter = document.createElement("div");
                    levelMeter.className = "level-meter";
                    const levelBar = document.createElement("div");
                    levelBar.className = "level-bar";
                    levelMeter.appendChild(levelBar);

                    const panControl = document.createElement("div");
                    panControl.className = "pan-control";

                    const panLabel = document.createElement("label");
                    panLabel.textContent = "Pan:";

                    const panSlider = document.createElement("input");
                    panSlider.type = "range";
                    panSlider.className = "pan-slider";
                    panSlider.min = "-1";
                    panSlider.max = "1";
                    panSlider.step = "0.1";
                    panSlider.value = this.panPosition.toString();

                    const panValue = document.createElement("span");
                    panValue.className = "pan-value";
                    panValue.textContent = this.panPosition.toFixed(1);

                    panControl.appendChild(panLabel);
                    panControl.appendChild(panSlider);
                    panControl.appendChild(panValue);

                    unit.appendChild(header);
                    unit.appendChild(noteDisplay);
                    unit.appendChild(expressionDisplay);
                    unit.appendChild(levelMeter);
                    unit.appendChild(panControl);

                    this.element = unit;
                    this.noteDisplay = noteDisplay;
                    this.expressionDisplay = expressionDisplay;
                    this.levelMeter = levelBar;
                    this.panControl = panSlider;

                    panSlider.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.panner.pan.value = value;
                        panValue.textContent = value.toFixed(1);
                    });

                    return unit;
                }
            }

            // Initialize audio system when needed (user interaction required)
            async function initializeAudioSystem() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext ||
                        window.webkitAudioContext)();

                    if (audioContext.state === "suspended") {
                        await audioContext.resume();
                        log("Audio context resumed", "info");
                    }

                    masterGain = audioContext.createGain();
                    masterGain.gain.value = 0.7;
                    masterGain.connect(audioContext.destination);

                    log("Loading audio worklets...", "info");
                    await audioContext.audioWorklet.addModule(
                        "../src/worklets/bowed_string_worklet.js",
                    );
                    await audioContext.audioWorklet.addModule(
                        "../src/worklets/reverb_worklet.js",
                    );
                    await audioContext.audioWorklet.addModule(
                        "../src/worklets/pink_noise.js",
                    );
                    log("Audio worklets loaded successfully", "info");
                }
            }

            window.initializeEnsemble = async function initializeEnsemble() {
                const synthCount = parseInt(
                    document.getElementById("synth-count").value,
                );

                try {
                    // Initialize audio system first
                    await initializeAudioSystem();

                    // Ensure all synths have audio initialized
                    for (const synth of synths) {
                        await synth.ensureAudioInitialized(
                            audioContext,
                            masterGain,
                        );
                    }

                    log(`Audio initialized for ${synthCount} synths`, "info");
                } catch (error) {
                    log(
                        `Failed to initialize ensemble audio: ${error.message}`,
                        "error",
                    );
                    console.error(error);
                }
            };

            async function startCalibrationMode() {
                if (!isInitialized) {
                    log("Please initialize synths first", "error");
                    return;
                }

                // Ensure audio system is initialized
                await initializeAudioSystem();

                // Ensure all synths have audio initialized
                for (const synth of synths) {
                    await synth.ensureAudioInitialized(
                        audioContext,
                        masterGain,
                    );
                }

                log("Starting calibration mode...", "info");
                inCalibrationMode = true;

                // Start calibration noise on all synths
                for (const synth of synths) {
                    if (synth.synthCore && synth.synthCore.isInitialized) {
                        synth.synthCore.startCalibrationNoise(0.7);
                    }
                }

                // Update UI
                document.getElementById("calibration_phase").style.display =
                    "none";
                document.getElementById("join_phase").style.display = "block";

                log("Calibration noise started on all synths", "info");
            }

            async function joinInstrument() {
                log("Joining instrument...", "info");
                inCalibrationMode = false;

                // Stop calibration noise on all synths
                for (const synth of synths) {
                    if (synth.synthCore && synth.synthCore.isInitialized) {
                        synth.synthCore.stopCalibrationNoise();
                        await synth.synthCore.setPower(true);
                    }
                }

                // Update UI - hide both phases
                document.getElementById("calibration_phase").style.display =
                    "none";
                document.getElementById("join_phase").style.display = "none";

                log("Joined instrument in synthesis mode", "info");
            }

            // Connect all synths to controller
            function connectAllSynthsToController() {
                log(
                    `Attempting to connect ${synths.length} synths to controller`,
                    "info",
                );
                for (const synth of synths) {
                    log(`Connecting synth: ${synth.id}`, "info");
                    connectSynthToController(synth);
                }
            }

            // Helper function to connect a single synth
            function connectSynthToController(synth) {
                if (!synth.ws) {
                    const protocol =
                        window.location.protocol === "https:" ? "wss:" : "ws:";
                    const wsUrl = `${protocol}//${window.location.host}/ws`;
                    log(
                        `[${synth.id}] Attempting WebSocket connection to ${wsUrl}`,
                        "info",
                    );

                    synth.ws = new WebSocket(wsUrl);

                    synth.ws.addEventListener("open", () => {
                        log(
                            `[${synth.id}] WebSocket connected successfully`,
                            "info",
                        );

                        // Register with server
                        const registerMsg = {
                            type: "register",
                            client_id: synth.id,
                        };
                        log(
                            `[${synth.id}] Sending registration: ${JSON.stringify(registerMsg)}`,
                            "info",
                        );
                        synth.ws.send(JSON.stringify(registerMsg));

                        // Request list of active controllers
                        const requestMsg = {
                            type: "request-controllers",
                            source: synth.id,
                        };
                        log(
                            `[${synth.id}] Requesting controllers: ${JSON.stringify(requestMsg)}`,
                            "info",
                        );
                        synth.ws.send(JSON.stringify(requestMsg));
                    });

                    synth.ws.addEventListener("message", async (event) => {
                        const message = JSON.parse(event.data);
                        await handleSynthMessage(synth, message);
                    });

                    synth.ws.addEventListener("close", (event) => {
                        log(
                            `[${synth.id}] WebSocket disconnected (code: ${event.code}, reason: ${event.reason}) - reconnecting...`,
                            "info",
                        );
                        synth.ws = null;

                        // Reconnect after 2 seconds
                        setTimeout(() => {
                            log(
                                `[${synth.id}] Attempting reconnection...`,
                                "info",
                            );
                            connectSynthToController(synth);
                        }, 2000);
                    });

                    synth.ws.addEventListener("error", (error) => {
                        log(
                            `[${synth.id}] WebSocket error: ${JSON.stringify(error)}`,
                            "error",
                        );
                        console.error(
                            `WebSocket error for ${synth.id}:`,
                            error,
                        );
                    });
                } else {
                    log(
                        `[${synth.id}] WebSocket already exists, skipping connection`,
                        "info",
                    );
                }
            }

            async function handleSynthMessage(synth, message) {
                log(`[${synth.id}] Received message: ${message.type}`, "info");
                console.log(`[${synth.id}] Full message:`, message);

                switch (message.type) {
                    case "controllers-list":
                        // Available controllers list received
                        log(
                            `[${synth.id}] Received controllers list: ${message.controllers.join(", ")}`,
                            "info",
                        );
                        for (const controllerId of message.controllers) {
                            if (!synth.controllers.has(controllerId)) {
                                log(
                                    `[${synth.id}] Discovered controller: ${controllerId}`,
                                    "info",
                                );
                                synth.controllers.set(controllerId, {
                                    connected: false,
                                    connection: null,
                                    channel: null,
                                    command_channel: null,
                                    ice_queue: [],
                                });
                                // Auto-connect to controllers
                                connectSynthToSpecificController(
                                    synth,
                                    controllerId,
                                );
                            }
                        }
                        break;
                    case "answer":
                        await handleControllerAnswer(synth, message);
                        break;
                    case "ice":
                        await handleIceCandidate(synth, message);
                        break;
                    case "controller-joined":
                        // New controller joined - auto-connect
                        log(
                            `[${synth.id}] New controller joined: ${message.controller_id}`,
                            "info",
                        );
                        if (!synth.controllers.has(message.controller_id)) {
                            synth.controllers.set(message.controller_id, {
                                connected: false,
                                connection: null,
                                channel: null,
                                command_channel: null,
                                ice_queue: [],
                            });
                            // Auto-connect to new controller
                            connectSynthToSpecificController(
                                synth,
                                message.controller_id,
                            );
                        }
                        break;
                    case "controller-left":
                        // Controller disconnected
                        log(
                            `[${synth.id}] Controller left: ${message.controller_id}`,
                            "info",
                        );
                        if (synth.controllers.has(message.controller_id)) {
                            const controller = synth.controllers.get(
                                message.controller_id,
                            );
                            // Close connection if exists
                            if (controller.connection) {
                                controller.connection.close();
                            }
                            synth.controllers.delete(message.controller_id);
                        }
                        break;
                    default:
                        console.log(
                            `[${synth.id}] Unknown message type: ${message.type}`,
                        );
                }
            }

            async function connectSynthToSpecificController(
                synth,
                controllerId,
            ) {
                log(
                    `[${synth.id}] Initiating connection to controller ${controllerId}`,
                    "info",
                );

                const pc = new RTCPeerConnection(rtcConfig);
                const controller = synth.controllers.get(controllerId);
                controller.connection = pc;
                controller.ice_queue = [];

                // Create data channels
                const param_channel = pc.createDataChannel("params", {
                    ordered: false,
                    maxRetransmits: 0,
                });
                const command_channel = pc.createDataChannel("commands", {
                    ordered: true,
                });

                controller.channel = param_channel;
                controller.command_channel = command_channel;

                // Set up param channel handlers
                param_channel.addEventListener("open", () => {
                    log(
                        `[${synth.id}] Param channel open to ${controllerId}`,
                        "info",
                    );
                    controller.connected = true;

                    // Send immediate state update
                    param_channel.send(
                        JSON.stringify({
                            type: "pong",
                            timestamp: Date.now(),
                            state: {
                                audio_enabled: true,
                                joined: synth.isActive,
                            },
                        }),
                    );
                });

                param_channel.addEventListener("message", (event) => {
                    synth.handleParamMessage(event);
                });

                param_channel.addEventListener("close", () => {
                    log(
                        `[${synth.id}] Param channel closed to ${controllerId}`,
                        "info",
                    );
                    controller.connected = false;
                });

                // Set up command channel handlers
                command_channel.addEventListener("message", (event) => {
                    const command = JSON.parse(event.data);
                    if (command.type === "command") {
                        synth.handleCommandMessage(event);
                    }
                });

                // Handle ICE candidates
                pc.addEventListener("icecandidate", (event) => {
                    if (event.candidate) {
                        synth.ws.send(
                            JSON.stringify({
                                type: "ice",
                                source: synth.id,
                                target: controllerId,
                                data: event.candidate,
                            }),
                        );
                    }
                });

                // Handle connection state
                pc.addEventListener("connectionstatechange", () => {
                    log(
                        `[${synth.id}] Connection state to ${controllerId}: ${pc.connectionState}`,
                        "info",
                    );

                    if (
                        pc.connectionState === "failed" ||
                        pc.connectionState === "closed"
                    ) {
                        controller.connected = false;
                    }
                });

                // Create and send offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                synth.ws.send(
                    JSON.stringify({
                        type: "offer",
                        source: synth.id,
                        target: controllerId,
                        data: offer,
                    }),
                );
            }

            async function handleControllerAnswer(synth, message) {
                const controller = synth.controllers.get(message.source);
                if (controller && controller.connection) {
                    await controller.connection.setRemoteDescription(
                        message.data,
                    );

                    // Process any queued ICE candidates
                    if (
                        controller.ice_queue &&
                        controller.ice_queue.length > 0
                    ) {
                        log(
                            `[${synth.id}] Processing ${controller.ice_queue.length} queued ICE candidates`,
                            "info",
                        );
                        for (const candidate of controller.ice_queue) {
                            await controller.connection.addIceCandidate(
                                candidate,
                            );
                        }
                        controller.ice_queue = [];
                    }
                }
            }

            async function handleIceCandidate(synth, message) {
                const controller = synth.controllers.get(message.source);
                if (controller && controller.connection) {
                    if (controller.connection.remoteDescription) {
                        await controller.connection.addIceCandidate(
                            message.data,
                        );
                    } else {
                        // Queue ICE candidate if remote description isn't set yet
                        if (!controller.ice_queue) {
                            controller.ice_queue = [];
                        }
                        controller.ice_queue.push(message.data);
                        log(
                            `[${synth.id}] Queued ICE candidate from ${message.source}`,
                            "info",
                        );
                    }
                }
            }

            // Event listeners
            document
                .getElementById("start_calibration")
                .addEventListener("click", startCalibrationMode);
            document
                .getElementById("join_instrument")
                .addEventListener("click", joinInstrument);

            function updateLevelMeters() {
                if (!isInitialized) return;

                synths.forEach((synth) => {
                    synth.updateLevel();
                });

                requestAnimationFrame(updateLevelMeters);
            }

            function log(message, type = "info") {
                const logArea = document.getElementById("log-area");
                const entry = document.createElement("div");
                entry.className = `log-entry ${type}`;
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                logArea.appendChild(entry);
                logArea.scrollTop = logArea.scrollHeight;

                // Keep only last 100 entries
                while (logArea.children.length > 100) {
                    logArea.removeChild(logArea.firstChild);
                }
            }

            // Volume control
            document
                .getElementById("master-volume")
                .addEventListener("input", (e) => {
                    const value = parseFloat(e.target.value);
                    if (masterGain) {
                        masterGain.gain.value = value;
                    }
                    document.getElementById("volume-display").textContent =
                        `${Math.round(value * 100)}%`;
                });

            // Automatic initialization on page load
            document.addEventListener("DOMContentLoaded", async function () {
                log("Page loaded - initializing ensemble connections", "info");

                // Initialize synth objects and WebSocket connections without audio
                const synthCount = parseInt(
                    document.getElementById("synth-count").value,
                );

                try {
                    // Clear existing synths
                    synths.forEach((synth) => {
                        if (synth.element && synth.element.parentNode) {
                            synth.element.parentNode.removeChild(synth.element);
                        }
                    });
                    synths = [];

                    const synthGrid = document.getElementById("synth-grid");
                    synthGrid.innerHTML = "";

                    // Create synth objects without audio initialization
                    for (let i = 0; i < synthCount; i++) {
                        const synthId = `synth-${i}`;
                        log(`Creating synth: ${synthId}`, "info");
                        const synth = new TestSynth(synthId, i, synthCount);
                        synth.createElements(synthGrid);
                        synth.loadSynthBanksFromStorage();
                        synths.push(synth);
                        log(`Synth created with ID: ${synth.id}`, "info");
                    }

                    isInitialized = true;
                    log(
                        `Initialized ${synthCount} synths (audio deferred)`,
                        "info",
                    );

                    // Connect to controller automatically
                    connectAllSynthsToController();

                    updateLevelMeters();
                } catch (error) {
                    log(
                        `Failed to initialize ensemble: ${error.message}`,
                        "error",
                    );
                    console.error(error);
                }
            });
        </script>
    </body>
</html>
