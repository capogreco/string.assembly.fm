<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>String Assembly FM - Multi-Synth Test Client</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
                background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
                min-height: 100vh;
                color: white;
                padding: 20px;
            }

            .container {
                max-width: 1200px;
                margin: 0 auto;
            }

            h1 {
                text-align: center;
                margin-bottom: 30px;
                text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            }

            .controls {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                margin-bottom: 30px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .control-row {
                display: flex;
                gap: 20px;
                align-items: center;
                margin-bottom: 15px;
            }

            button {
                padding: 10px 20px;
                border: none;
                border-radius: 6px;
                background: #3498db;
                color: white;
                font-weight: 500;
                cursor: pointer;
                transition: all 0.3s ease;
            }

            button:hover {
                background: #2980b9;
                transform: translateY(-2px);
            }

            button:disabled {
                background: #7f8c8d;
                cursor: not-allowed;
                transform: none;
            }

            .synth-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 20px;
            }

            .synth-unit {
                background: rgba(255, 255, 255, 0.1);
                border-radius: 12px;
                padding: 20px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.2);
                transition: all 0.3s ease;
            }

            .synth-unit.active {
                border-color: #3498db;
                box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
            }

            .synth-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 15px;
            }

            .synth-id {
                font-weight: bold;
                font-size: 1.1em;
            }

            .status-dot {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: #e74c3c;
            }

            .status-dot.connected {
                background: #2ecc71;
            }

            .note-display {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                padding: 10px;
                margin-bottom: 10px;
                font-family: monospace;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.2em;
            }

            .expression-display {
                font-size: 0.9em;
                color: rgba(255, 255, 255, 0.8);
                margin-bottom: 10px;
            }

            .level-meter {
                height: 100px;
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                position: relative;
                overflow: hidden;
                margin-bottom: 10px;
            }

            .level-bar {
                position: absolute;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(to top, #2ecc71, #f1c40f, #e74c3c);
                transition: height 0.1s ease;
            }

            .pan-control {
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 0.9em;
            }

            .pan-slider {
                flex: 1;
            }

            .log-area {
                background: rgba(0, 0, 0, 0.3);
                border-radius: 6px;
                padding: 15px;
                margin-top: 30px;
                font-family: monospace;
                font-size: 0.9em;
                max-height: 200px;
                overflow-y: auto;
            }

            .log-entry {
                margin-bottom: 5px;
                opacity: 0.8;
            }

            .log-entry.error {
                color: #e74c3c;
            }

            .log-entry.info {
                color: #3498db;
            }

            input[type="number"] {
                width: 60px;
                padding: 5px;
                border: 1px solid rgba(255, 255, 255, 0.3);
                background: rgba(255, 255, 255, 0.1);
                color: white;
                border-radius: 4px;
            }

            input[type="range"] {
                width: 100%;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>ðŸŽ¼ Multi-Synth Test Ensemble</h1>

            <div class="controls">
                <div class="control-row">
                    <label>Number of Synths:</label>
                    <input
                        type="number"
                        id="synth-count"
                        value="6"
                        min="1"
                        max="12"
                    />
                    <button onclick="initializeEnsemble()">Initialize</button>
                    <button onclick="connectToController()">
                        Connect to Controller
                    </button>
                    <button id="start-all" onclick="startAllSynths()" disabled>
                        Start All
                    </button>
                    <button id="stop-all" onclick="stopAllSynths()" disabled>
                        Stop All
                    </button>
                </div>
                <div class="control-row">
                    <label>Master Volume:</label>
                    <input
                        type="range"
                        id="master-volume"
                        min="0"
                        max="1"
                        step="0.01"
                        value="0.7"
                    />
                    <span id="volume-display">70%</span>
                </div>
            </div>

            <div class="synth-grid" id="synth-grid">
                <!-- Synth units will be generated here -->
            </div>

            <div class="log-area" id="log-area">
                <div class="log-entry info">
                    Multi-synth test client ready. Click Initialize to begin.
                </div>
            </div>
        </div>

        <script>
            // Global state
            let audioContext = null;
            let synths = [];
            let controllerConnection = null;
            let masterGain = null;
            let isInitialized = false;

            // Real WebRTC configuration
            const rtcConfig = {
                iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
            };

            // Synth class
            class TestSynth {
                constructor(id, index, totalSynths) {
                    this.id = id;
                    this.index = index;
                    this.element = null;
                    this.noteDisplay = null;
                    this.expressionDisplay = null;
                    this.levelMeter = null;
                    this.panControl = null;

                    // Audio nodes
                    this.bowedString = null;
                    this.gain = null;
                    this.panner = null;
                    this.analyser = null;

                    // State
                    this.currentNote = null;
                    this.currentExpression = null;
                    this.isActive = false;
                    this.currentProgram = null;

                    // Banking
                    this.synthBanks = new Map();

                    // WebRTC connections (will be set up later)
                    this.ws = null;
                    this.controllers = new Map();

                    // Calculate pan position
                    this.panPosition =
                        totalSynths === 1
                            ? 0
                            : (index / (totalSynths - 1)) * 2 - 1;
                }

                async initialize(audioCtx, destination) {
                    // Create audio nodes
                    this.gain = audioCtx.createGain();
                    this.gain.gain.value = 0;

                    this.panner = audioCtx.createStereoPanner();
                    this.panner.pan.value = this.panPosition;

                    this.analyser = audioCtx.createAnalyser();
                    this.analyser.fftSize = 256;

                    // Create bowed string worklet
                    try {
                        // Verify worklet is available
                        if (!audioCtx.audioWorklet) {
                            throw new Error("AudioWorklet not supported");
                        }

                        this.bowedString = new AudioWorkletNode(
                            audioCtx,
                            "continuous-excitation-processor",
                            {
                                numberOfInputs: 0,
                                numberOfOutputs: 1,
                                outputChannelCount: [2],
                            },
                        );

                        // Connect audio graph
                        this.bowedString.connect(this.gain);
                        this.gain.connect(this.analyser);
                        this.analyser.connect(this.panner);
                        this.panner.connect(destination);

                        // Initialize parameters to defaults
                        const defaultParams = {
                            fundamentalFrequency: 220,
                            bowForce: 0.3,
                            bowPosition: 0.1,
                            bowSpeed: 0.5,
                            stringDamping: 0.1,
                            stringMaterial: 0.5,
                            brightness: 0.5,
                            masterGain: 0.8,
                        };

                        for (const [param, value] of Object.entries(
                            defaultParams,
                        )) {
                            if (this.bowedString.parameters.has(param)) {
                                this.bowedString.parameters
                                    .get(param)
                                    .setValueAtTime(
                                        value,
                                        audioCtx.currentTime,
                                    );
                            }
                        }

                        log(`[${this.id}] Audio graph initialized`, "info");
                    } catch (error) {
                        log(
                            `[${this.id}] Failed to create audio nodes: ${error.message}`,
                            "error",
                        );
                        console.error(error);
                    }
                }

                handleParamMessage(event) {
                    const data =
                        typeof event.data === "string"
                            ? JSON.parse(event.data)
                            : event.data;

                    log(
                        `[${this.id}] Received param message: ${data.type}`,
                        "info",
                    );

                    if (data.type === "program") {
                        this.applyProgram(data.program, data.transition);
                    } else if (data.type === "setTransitionConfig") {
                        // Forward transition config to worklet
                        if (this.bowedString) {
                            this.bowedString.port.postMessage({
                                type: "setTransitionConfig",
                                config: data.config,
                            });
                            log(
                                `[${this.id}] Applied transition config: ${JSON.stringify(data.config)}`,
                                "info",
                            );
                        }
                    } else if (data.type === "ping") {
                        if (
                            this.paramChannel &&
                            this.paramChannel.readyState === "open"
                        ) {
                            this.paramChannel.send(
                                JSON.stringify({
                                    type: "pong",
                                    timestamp: data.timestamp,
                                    state: {
                                        audio_enabled: true,
                                        joined: this.isActive,
                                    },
                                }),
                            );
                        }
                    }
                }

                handleCommandMessage(event) {
                    const data =
                        typeof event.data === "string"
                            ? JSON.parse(event.data)
                            : event.data;

                    if (data.type === "command") {
                        if (data.name === "power") {
                            this.setPower(data.value);
                        } else if (data.name === "save") {
                            this.handleSaveCommand(data.bank || data.value);
                        } else if (data.name === "load") {
                            this.handleLoadCommand(
                                data.bank,
                                data.fallbackProgram,
                            );
                        }
                    }
                }

                applyProgram(program, transition) {
                    log(
                        `[${this.id}] Applying program: freq=${program.fundamentalFrequency?.toFixed(1)}Hz${transition ? " with transition" : ""}`,
                        "info",
                    );

                    // Store current program for banking
                    this.currentProgram = program;

                    // Update display
                    if (program.fundamentalFrequency) {
                        const noteInfo = this.frequencyToNote(
                            program.fundamentalFrequency,
                        );
                        this.currentNote = noteInfo.note;
                        this.noteDisplay.textContent = noteInfo.note;
                    }

                    // Update expression display
                    let expression = "None";
                    if (program.vibratoEnabled) expression = "Vibrato";
                    else if (program.tremoloEnabled) expression = "Tremolo";
                    else if (program.trillEnabled) expression = "Trill";
                    this.currentExpression = expression;
                    this.expressionDisplay.textContent = `Expression: ${expression}`;

                    // Apply to worklet
                    if (this.bowedString) {
                        const defaultPeriod = 0.5; // 500ms default transition
                        const lag = transition?.lag?.min || 0;
                        const startTime = audioContext.currentTime + lag;

                        // Send timed expression state to worklet
                        let targetExpressionType = "NONE";
                        if (program.vibratoEnabled)
                            targetExpressionType = "VIBRATO";
                        else if (program.tremoloEnabled)
                            targetExpressionType = "TREMOLO";
                        else if (program.trillEnabled)
                            targetExpressionType = "TRILL";

                        setTimeout(() => {
                            if (this.bowedString) {
                                // Re-check in case synth was destroyed
                                this.bowedString.port.postMessage({
                                    type: "setExpression",
                                    expression: targetExpressionType,
                                });
                                log(
                                    `[${this.id}] Sent setExpression: ${targetExpressionType} at ${lag.toFixed(3)}s lag`,
                                    "info",
                                );
                            }
                        }, lag * 1000);

                        for (const [param, value] of Object.entries(program)) {
                            // Skip expression enable flags - they're now handled by the timed setExpression message
                            if (
                                param === "vibratoEnabled" ||
                                param === "tremoloEnabled" ||
                                param === "trillEnabled"
                            ) {
                                continue;
                            }

                            // Handle AudioParams
                            if (this.bowedString.parameters.has(param)) {
                                const audioParam =
                                    this.bowedString.parameters.get(param);
                                const currentValue = audioParam.value;
                                const targetValue =
                                    typeof value === "boolean"
                                        ? value
                                            ? 1
                                            : 0
                                        : value;

                                // Skip if value hasn't changed (unless it's fundamental frequency, always set for note on)
                                if (
                                    param !== "fundamentalFrequency" &&
                                    Math.abs(currentValue - targetValue) < 0.001
                                ) {
                                    continue;
                                }

                                const period =
                                    transition?.period?.min || defaultPeriod;
                                // lag and startTime are already defined outside this loop
                                const endTime = startTime + period;

                                // Cancel any scheduled changes and pin current value
                                audioParam.cancelScheduledValues(
                                    audioContext.currentTime,
                                );
                                audioParam.setValueAtTime(
                                    currentValue,
                                    audioContext.currentTime,
                                );

                                if (transition) {
                                    // Check if transition object exists
                                    // Smooth transition for continuous parameters
                                    if (
                                        param === "fundamentalFrequency" &&
                                        targetValue > 0 && // Ensure target is valid
                                        currentValue > 0 // Ensure current is valid for ramp
                                    ) {
                                        // Exponential for frequency
                                        audioParam.exponentialRampToValueAtTime(
                                            targetValue,
                                            endTime,
                                        );
                                    } else {
                                        // Linear for everything else
                                        audioParam.linearRampToValueAtTime(
                                            targetValue,
                                            endTime,
                                        );
                                    }
                                    log(
                                        `[${this.id}] Transitioning ${param} from ${currentValue.toFixed(3)} to ${targetValue.toFixed(3)} over ${period.toFixed(3)}s starting at ${lag.toFixed(3)}s lag`,
                                        "info",
                                    );
                                } else {
                                    // Immediate change if no transition object
                                    audioParam.setValueAtTime(
                                        targetValue,
                                        startTime, // If lag is 0, this is effectively currentTime
                                    );
                                    log(
                                        `[${this.id}] Set ${param} immediately to ${targetValue.toFixed(3)} at ${startTime.toFixed(3)}s`,
                                        "info",
                                    );
                                }
                            }
                            // Handle discrete parameters via timed messages
                            else if (
                                param === "stringMaterial" ||
                                param === "bodyType"
                            ) {
                                setTimeout(() => {
                                    if (this.bowedString) {
                                        // Re-check in case synth was destroyed
                                        this.bowedString.port.postMessage({
                                            type:
                                                param === "stringMaterial"
                                                    ? "setStringMaterial"
                                                    : "setBodyType",
                                            value: value,
                                        });
                                        log(
                                            `[${this.id}] Sent ${param}: ${value} at ${lag.toFixed(3)}s lag`,
                                            "info",
                                        );
                                    }
                                }, lag * 1000);
                            }
                            // Else, if it's not an AudioParam and not a handled discrete param, log it (optional)
                            // else {
                            //    log(`[${this.id}] Unhandled program parameter (within loop): ${param}`, "info");
                            // }
                        } // End of for...of Object.entries(program)

                        // Start bowing (if applicable and synth is active)
                        // Assuming this.isActive reflects whether the synth *should* be making sound
                        // and this.bowedString confirms the worklet is ready.
                        if (this.bowedString && this.isActive !== false) {
                            // isActive could be undefined initially
                            this.bowedString.port.postMessage({
                                type: "setBowing",
                                value: true,
                            });
                            log(`[${this.id}] Sent setBowing: true`, "info");
                        }
                    } // End of if (this.bowedString) for applying parameters

                    this.element.classList.add("active");
                    log(
                        `[${this.id}] Program applied and synth UI activated`,
                        "info",
                    );
                } // End of applyProgram method

                setPower(on) {
                    const targetGain = on ? 0.7 : 0;
                    this.gain.gain.linearRampToValueAtTime(
                        targetGain,
                        audioContext.currentTime + 0.1,
                    );
                    this.isActive = on;

                    if (on) {
                        this.element.classList.add("active");
                    } else {
                        this.element.classList.remove("active");
                    }
                }

                handleSaveCommand(bankId) {
                    if (!this.currentProgram) {
                        log(`[${this.id}] No current program to save`, "error");
                        return;
                    }

                    // Store a deep copy of current resolved parameters
                    const savedProgram = JSON.parse(
                        JSON.stringify(this.currentProgram),
                    );
                    this.synthBanks.set(bankId, savedProgram);

                    // Also save to localStorage for persistence
                    try {
                        const allBanks = {};
                        this.synthBanks.forEach((program, id) => {
                            allBanks[id] = program;
                        });
                        localStorage.setItem(
                            `synth-banks-${this.id}`,
                            JSON.stringify(allBanks),
                        );
                        log(
                            `[${this.id}] Saved resolved parameters to bank ${bankId}`,
                            "info",
                        );
                    } catch (e) {
                        log(
                            `[${this.id}] Failed to save banks to localStorage: ${e.message}`,
                            "error",
                        );
                    }
                }

                handleLoadCommand(bankId, fallbackProgram) {
                    if (this.synthBanks.has(bankId)) {
                        // This synth has saved state - restore exact values
                        const savedProgram = this.synthBanks.get(bankId);
                        log(
                            `[${this.id}] Loading saved parameters from bank ${bankId}`,
                            "info",
                        );
                        this.applyProgram(savedProgram);
                    } else if (fallbackProgram) {
                        // New synth - use fallback program from controller
                        log(
                            `[${this.id}] New synth using fallback program for bank ${bankId}`,
                            "info",
                        );
                        this.applyProgram(fallbackProgram);
                    } else {
                        log(
                            `[${this.id}] Bank ${bankId} not found and no fallback program provided`,
                            "error",
                        );
                    }
                }

                loadSynthBanksFromStorage() {
                    try {
                        const saved = localStorage.getItem(
                            `synth-banks-${this.id}`,
                        );
                        if (saved) {
                            const banksData = JSON.parse(saved);
                            Object.entries(banksData).forEach(
                                ([bankId, program]) => {
                                    this.synthBanks.set(
                                        parseInt(bankId),
                                        program,
                                    );
                                },
                            );
                            log(
                                `[${this.id}] Loaded ${this.synthBanks.size} saved banks from storage`,
                                "info",
                            );
                        }
                    } catch (e) {
                        log(
                            `[${this.id}] Failed to load banks from storage: ${e.message}`,
                            "error",
                        );
                    }
                }

                frequencyToNote(freq) {
                    const A4 = 440;
                    const semitones = Math.round(12 * Math.log2(freq / A4));
                    const noteNames = [
                        "C",
                        "C#",
                        "D",
                        "D#",
                        "E",
                        "F",
                        "F#",
                        "G",
                        "G#",
                        "A",
                        "A#",
                        "B",
                    ];
                    const octave = Math.floor((semitones + 57) / 12);
                    const noteIndex = (semitones + 69) % 12;
                    return { note: noteNames[noteIndex] + octave, semitones };
                }

                updateLevel() {
                    if (!this.analyser || !this.levelMeter) return;

                    const dataArray = new Uint8Array(
                        this.analyser.frequencyBinCount,
                    );
                    this.analyser.getByteFrequencyData(dataArray);

                    let sum = 0;
                    for (let i = 0; i < dataArray.length; i++) {
                        sum += dataArray[i];
                    }
                    const average = sum / dataArray.length;
                    const normalizedLevel = average / 255;

                    this.levelMeter.style.height = `${normalizedLevel * 100}%`;
                }

                createUI() {
                    const unit = document.createElement("div");
                    unit.className = "synth-unit";

                    const header = document.createElement("div");
                    header.className = "synth-header";

                    const synthId = document.createElement("span");
                    synthId.className = "synth-id";
                    synthId.textContent = this.id;

                    const statusDot = document.createElement("div");
                    statusDot.className = "status-dot connected";

                    header.appendChild(synthId);
                    header.appendChild(statusDot);

                    const noteDisplay = document.createElement("div");
                    noteDisplay.className = "note-display";
                    noteDisplay.textContent = "--";

                    const expressionDisplay = document.createElement("div");
                    expressionDisplay.className = "expression-display";
                    expressionDisplay.textContent = "Expression: None";

                    const levelMeter = document.createElement("div");
                    levelMeter.className = "level-meter";
                    const levelBar = document.createElement("div");
                    levelBar.className = "level-bar";
                    levelMeter.appendChild(levelBar);

                    const panControl = document.createElement("div");
                    panControl.className = "pan-control";

                    const panLabel = document.createElement("label");
                    panLabel.textContent = "Pan:";

                    const panSlider = document.createElement("input");
                    panSlider.type = "range";
                    panSlider.className = "pan-slider";
                    panSlider.min = "-1";
                    panSlider.max = "1";
                    panSlider.step = "0.1";
                    panSlider.value = this.panPosition.toString();

                    const panValue = document.createElement("span");
                    panValue.className = "pan-value";
                    panValue.textContent = this.panPosition.toFixed(1);

                    panControl.appendChild(panLabel);
                    panControl.appendChild(panSlider);
                    panControl.appendChild(panValue);

                    unit.appendChild(header);
                    unit.appendChild(noteDisplay);
                    unit.appendChild(expressionDisplay);
                    unit.appendChild(levelMeter);
                    unit.appendChild(panControl);

                    this.element = unit;
                    this.noteDisplay = noteDisplay;
                    this.expressionDisplay = expressionDisplay;
                    this.levelMeter = levelBar;
                    this.panControl = panSlider;

                    panSlider.addEventListener("input", (e) => {
                        const value = parseFloat(e.target.value);
                        this.panner.pan.value = value;
                        panValue.textContent = value.toFixed(1);
                    });

                    return unit;
                }
            }

            async function initializeEnsemble() {
                const synthCount = parseInt(
                    document.getElementById("synth-count").value,
                );

                try {
                    if (!audioContext) {
                        audioContext = new (window.AudioContext ||
                            window.webkitAudioContext)();

                        if (audioContext.state === "suspended") {
                            await audioContext.resume();
                            log("Audio context resumed", "info");
                        }

                        masterGain = audioContext.createGain();
                        masterGain.gain.value = 0.7;
                        masterGain.connect(audioContext.destination);

                        log("Loading audio worklets...", "info");
                        await audioContext.audioWorklet.addModule(
                            "../src/worklets/bowed_string_worklet.js",
                        );
                        await audioContext.audioWorklet.addModule(
                            "../src/worklets/reverb_worklet.js",
                        );
                        await audioContext.audioWorklet.addModule(
                            "../src/worklets/pink_noise.js",
                        );
                        log("Audio worklets loaded successfully", "info");
                    }

                    synths.forEach((synth) => {
                        if (synth.element && synth.element.parentNode) {
                            synth.element.parentNode.removeChild(synth.element);
                        }
                    });
                    synths = [];

                    const synthGrid = document.getElementById("synth-grid");
                    synthGrid.innerHTML = "";

                    for (let i = 0; i < synthCount; i++) {
                        const synth = new TestSynth(
                            `test-synth-${i}`,
                            i,
                            synthCount,
                        );
                        await synth.initialize(audioContext, masterGain);
                        synth.loadSynthBanksFromStorage();
                        synthGrid.appendChild(synth.createUI());
                        synths.push(synth);
                    }

                    document.getElementById("start-all").disabled = false;
                    document.getElementById("stop-all").disabled = false;

                    isInitialized = true;
                    log(`Initialized ${synthCount} synths`, "info");

                    updateLevelMeters();
                } catch (error) {
                    log(
                        `Failed to initialize ensemble: ${error.message}`,
                        "error",
                    );
                    console.error(error);
                }
            }

            function connectToController() {
                console.log("[DEBUG] connectToController called");
                if (!isInitialized) {
                    log("Please initialize synths first", "error");
                    return;
                }
                log("Connect to controller function called", "info");

                // Set up WebSocket connections for each synth
                for (const synth of synths) {
                    if (!synth.ws) {
                        const protocol =
                            window.location.protocol === "https:"
                                ? "wss:"
                                : "ws:";
                        synth.ws = new WebSocket(
                            `${protocol}//${window.location.host}/ws`,
                        );

                        synth.ws.addEventListener("open", () => {
                            log(`[${synth.id}] WebSocket connected`, "info");

                            // Register with server
                            synth.ws.send(
                                JSON.stringify({
                                    type: "register",
                                    client_id: synth.id,
                                }),
                            );

                            // Request list of active controllers
                            synth.ws.send(
                                JSON.stringify({
                                    type: "request-controllers",
                                    source: synth.id,
                                }),
                            );
                        });

                        synth.ws.addEventListener("message", async (event) => {
                            const message = JSON.parse(event.data);
                            await handleSynthMessage(synth, message);
                        });

                        synth.ws.addEventListener("close", () => {
                            log(`[${synth.id}] WebSocket disconnected`, "info");
                            synth.ws = null;
                        });

                        synth.ws.addEventListener("error", (error) => {
                            log(
                                `[${synth.id}] WebSocket error: ${error}`,
                                "error",
                            );
                        });
                    }
                }
            }

            async function handleSynthMessage(synth, message) {
                switch (message.type) {
                    case "controllers-list":
                        // Available controllers list received
                        log(
                            `[${synth.id}] Received controllers list: ${message.controllers.join(", ")}`,
                            "info",
                        );
                        for (const controllerId of message.controllers) {
                            if (!synth.controllers.has(controllerId)) {
                                log(
                                    `[${synth.id}] Discovered controller: ${controllerId}`,
                                    "info",
                                );
                                synth.controllers.set(controllerId, {
                                    connected: false,
                                    connection: null,
                                    channel: null,
                                    command_channel: null,
                                    ice_queue: [],
                                });
                                // Auto-connect to controllers
                                connectSynthToController(synth, controllerId);
                            }
                        }
                        break;
                    case "answer":
                        await handleControllerAnswer(synth, message);
                        break;
                    case "ice":
                        await handleIceCandidate(synth, message);
                        break;
                    default:
                        console.log(
                            `[${synth.id}] Unknown message type: ${message.type}`,
                        );
                }
            }

            async function connectSynthToController(synth, controllerId) {
                log(
                    `[${synth.id}] Initiating connection to controller ${controllerId}`,
                    "info",
                );

                const pc = new RTCPeerConnection(rtcConfig);
                const controller = synth.controllers.get(controllerId);
                controller.connection = pc;
                controller.ice_queue = [];

                // Create data channels
                const param_channel = pc.createDataChannel("params", {
                    ordered: false,
                    maxRetransmits: 0,
                });
                const command_channel = pc.createDataChannel("commands", {
                    ordered: true,
                });

                controller.channel = param_channel;
                controller.command_channel = command_channel;

                // Set up param channel handlers
                param_channel.addEventListener("open", () => {
                    log(
                        `[${synth.id}] Param channel open to ${controllerId}`,
                        "info",
                    );
                    controller.connected = true;

                    // Send immediate state update
                    param_channel.send(
                        JSON.stringify({
                            type: "pong",
                            timestamp: Date.now(),
                            state: {
                                audio_enabled: true,
                                joined: synth.isActive,
                            },
                        }),
                    );
                });

                param_channel.addEventListener("message", (event) => {
                    synth.handleParamMessage(event);
                });

                param_channel.addEventListener("close", () => {
                    log(
                        `[${synth.id}] Param channel closed to ${controllerId}`,
                        "info",
                    );
                    controller.connected = false;
                });

                // Set up command channel handlers
                command_channel.addEventListener("message", (event) => {
                    const command = JSON.parse(event.data);
                    if (command.type === "command") {
                        synth.handleCommandMessage(event);
                    }
                });

                // Handle ICE candidates
                pc.addEventListener("icecandidate", (event) => {
                    if (event.candidate) {
                        synth.ws.send(
                            JSON.stringify({
                                type: "ice",
                                source: synth.id,
                                target: controllerId,
                                data: event.candidate,
                            }),
                        );
                    }
                });

                // Handle connection state
                pc.addEventListener("connectionstatechange", () => {
                    log(
                        `[${synth.id}] Connection state to ${controllerId}: ${pc.connectionState}`,
                        "info",
                    );

                    if (
                        pc.connectionState === "failed" ||
                        pc.connectionState === "closed"
                    ) {
                        controller.connected = false;
                    }
                });

                // Create and send offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                synth.ws.send(
                    JSON.stringify({
                        type: "offer",
                        source: synth.id,
                        target: controllerId,
                        data: offer,
                    }),
                );
            }

            async function handleControllerAnswer(synth, message) {
                const controller = synth.controllers.get(message.source);
                if (controller && controller.connection) {
                    await controller.connection.setRemoteDescription(
                        message.data,
                    );

                    // Process any queued ICE candidates
                    if (
                        controller.ice_queue &&
                        controller.ice_queue.length > 0
                    ) {
                        log(
                            `[${synth.id}] Processing ${controller.ice_queue.length} queued ICE candidates`,
                            "info",
                        );
                        for (const candidate of controller.ice_queue) {
                            await controller.connection.addIceCandidate(
                                candidate,
                            );
                        }
                        controller.ice_queue = [];
                    }
                }
            }

            async function handleIceCandidate(synth, message) {
                const controller = synth.controllers.get(message.source);
                if (controller && controller.connection) {
                    if (controller.connection.remoteDescription) {
                        await controller.connection.addIceCandidate(
                            message.data,
                        );
                    } else {
                        // Queue ICE candidate if remote description isn't set yet
                        if (!controller.ice_queue) {
                            controller.ice_queue = [];
                        }
                        controller.ice_queue.push(message.data);
                        log(
                            `[${synth.id}] Queued ICE candidate from ${message.source}`,
                            "info",
                        );
                    }
                }
            }

            function startAllSynths() {
                synths.forEach((synth) => {
                    synth.setPower(true);
                });
            }

            function stopAllSynths() {
                synths.forEach((synth) => {
                    synth.setPower(false);
                });
            }

            function updateLevelMeters() {
                if (!isInitialized) return;

                synths.forEach((synth) => {
                    synth.updateLevel();
                });

                requestAnimationFrame(updateLevelMeters);
            }

            function log(message, type = "info") {
                const logArea = document.getElementById("log-area");
                const entry = document.createElement("div");
                entry.className = `log-entry ${type}`;
                entry.textContent = `${new Date().toLocaleTimeString()}: ${message}`;
                logArea.appendChild(entry);
                logArea.scrollTop = logArea.scrollHeight;

                // Keep only last 100 entries
                while (logArea.children.length > 100) {
                    logArea.removeChild(logArea.firstChild);
                }
            }

            // Volume control
            document
                .getElementById("master-volume")
                .addEventListener("input", (e) => {
                    const value = parseFloat(e.target.value);
                    if (masterGain) {
                        masterGain.gain.value = value;
                    }
                    document.getElementById("volume-display").textContent =
                        `${Math.round(value * 100)}%`;
                });
        </script>
    </body>
</html>
