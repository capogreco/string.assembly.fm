<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Assembly FM - Controller</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            text-shadow: none;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .section {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .section-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            display: grid;
            grid-template-columns: 1fr 2fr 80px;
            gap: 15px;
            align-items: center;
        }
        
        label {
            font-weight: 500;
            color: #34495e;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            transition: background 0.3s;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            background: white;
        }
        
        .value-display {
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
            text-align: right;
            min-width: 60px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #status {
            text-align: center;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 500;
            background: #e74c3c;
            color: white;
        }
        
        #status.connected {
            background: #27ae60;
        }
        
        #stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: #ecf0f1;
            border-radius: 6px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat strong {
            display: block;
            font-size: 1.2em;
            color: #2c3e50;
        }
        
        hr.separator {
            border: none;
            height: 2px;
            background: linear-gradient(to right, transparent, #667eea, transparent);
            margin: 25px 0;
        }
        
        .expression-group {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            display: none;
        }
        
        .expression-group.active {
            display: block;
        }
        
        .expression-group.vibrato {
            border-left: 4px solid #e74c3c;
        }
        
        .expression-group.trill {
            border-left: 4px solid #3498db;
        }
        
        .expression-group.tremolo {
            border-left: 4px solid #f39c12;
        }
        
        .expression-group-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .expression-group.vibrato .expression-group-title {
            color: #e74c3c;
        }
        
        .expression-group.trill .expression-group-title {
            color: #3498db;
        }
        
        .expression-group.tremolo .expression-group-title {
            color: #f39c12;
        }
        
        .program-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .program-controls button {
            flex: 1;
            padding: 10px 16px;
            font-size: 0.9em;
        }
        
        .banking-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .banking-controls select {
            flex: 1;
        }
        
        .banking-controls button {
            padding: 8px 16px;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }
        
        .banking-controls button.success {
            background: #28a745;
            color: white;
            animation: flash-success 0.8s ease-out;
        }
        
        .banking-controls button.error {
            background: #dc3545;
            color: white;
            animation: flash-error 0.8s ease-out;
        }
        
        @keyframes flash-success {
            0% { background: #28a745; transform: scale(1); }
            50% { background: #34ce57; transform: scale(1.05); }
            100% { background: #28a745; transform: scale(1); }
        }
        
        @keyframes flash-error {
            0% { background: #dc3545; transform: scale(1); }
            50% { background: #e94560; transform: scale(1.05); }
            100% { background: #dc3545; transform: scale(1); }
        }
        
        #synths {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }
        
        #synths h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .synth {
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border-radius: 4px;
            border-left: 4px solid #27ae60;
        }
        
        .synth.connecting {
            border-left-color: #f39c12;
        }
        
        .synth.disconnected {
            border-left-color: #e74c3c;
        }
        
        .latency {
            float: right;
            font-size: 0.8em;
            color: #666;
        }
        
        .synth-header {
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .synth-details {
            font-size: 0.85em;
            color: #555;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 4px;
        }
        
        .synth-details span {
            padding: 2px 6px;
            border-radius: 3px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .audio-state {
            border-color: #28a745 !important;
            background: #d4edda !important;
        }
        

        
        .synthesis-state {
            border-color: #17a2b8 !important;
            background: #d1ecf1 !important;
        }
        

        

        
        .audio-off {
            color: #e74c3c;
            font-size: 0.8em;
        }
        
        .warning {
            background: #ff9800;
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            display: none;
        }
        
        .warning.show {
            display: block;
        }
        
        /* Parameter change indicators */
        .control-group.changed {
            position: relative;
        }
        
        .control-group.changed::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 2px solid #ff9800;
            border-radius: 6px;
            pointer-events: none;
            animation: pulse-orange 2s infinite;
        }
        
        .control-group.sent {
            position: relative;
        }
        
        .control-group.sent::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 2px solid #4caf50;
            border-radius: 6px;
            pointer-events: none;
            animation: fade-green 1s ease-out forwards;
        }
        
        @keyframes pulse-orange {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        @keyframes fade-green {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Status indicator */
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .status-badge.synced {
            background: #4caf50;
            color: white;
        }
        
        .status-badge.pending {
            background: #ff9800;
            color: white;
            animation: pulse-orange 2s infinite;
        }
        
        .status-badge.sending {
            background: #2196f3;
            color: white;
        }
        
        /* Chord and Expression Control Styles */
        .chord-control {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .expression-display {
            margin-top: 15px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .note-expression {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            line-height: 1.4;
        }
        
        .note-expression.vibrato {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }
        
        .note-expression.tremolo {
            background: #fff3cd;
            color: #664d03;
            border: 1px solid #ffecb5;
        }
        
        .note-expression.trill {
            background: #cfe2ff;
            color: #0842a0;
            border: 1px solid #b6d4fe;
        }
        
        .note-expression.none {
            background: #e8daef;
            color: #6c3483;
            border: 1px solid #d2b4de;
        }
        
        /* Harmonic Ratio Selector Styles */
        .harmonic-selector {
            margin: 5px 0;
        }
        
        .harmonic-row {
            display: flex;
            gap: 4px;
            margin-bottom: 2px;
        }
        
        .harmonic-number {
            width: 28px;
            height: 28px;
            text-align: center;
            line-height: 28px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 0.9em;
            user-select: none;
            transition: all 0.2s ease;
        }
        
        .harmonic-number:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .harmonic-number.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .harmonic-number.selecting {
            background: #b3c6f7;
            border-color: #667eea;
        }
        
        /* Piano keyboard wrapper for interactive expressions */
        .piano-keyboard {
            position: relative;
            display: inline-block;
        }
        
        .piano-keyboard canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Gesture hint styles */
        .gesture-hint {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>String Assembly FM - Controller</h1>
        
        <div id="status">Disconnected</div>
        
        <div id="stats">
            <div class="stat">
                <strong id="connected_count">0</strong>
                <span>Connected</span>
            </div>
            <div class="stat">
                <strong id="avg_latency">-</strong>
                <span>Avg Latency</span>
            </div>
        </div>
        
        <div id="controller_warning" class="warning">
            ⚠️ Controller conflict detected - multiple controllers detected!
            <div id="other_controllers" style="font-size: 0.9em; margin-top: 5px;"></div>
            <button id="kick_others" style="margin-top: 10px; padding: 5px 15px; background: #d32f2f; color: white; border: none; border-radius: 3px; cursor: pointer;">Kick Other Controllers</button>
        </div>
        
        <div class="program-controls">
            <button id="send_current_program">Send Current Program</button>
            <span id="status_badge" class="status-badge synced">✓ Synced</span>
        </div>
        
        <div class="section">
            <div class="section-title">Chord & Expression Control</div>
            
            <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                <strong>Current Chord: </strong><span id="chord-display" style="color: #667eea;">None</span>
            </div>
            
            <div class="section-title">Piano</div>
            <div id="piano-container" style="margin: 10px 0;">
                <svg id="piano" width="750" height="80" style="border: 1px solid #ddd; border-radius: 4px; background: #fafafa;" xmlns="http://www.w3.org/2000/svg">
                    <!-- Piano keys will be generated by JavaScript -->
                </svg>
                <div style="font-size: 0.8em; color: #666; margin-top: 5px; text-align: center;">
                    <span id="piano-range-display">Range: C4-C6 (Violin)</span>
                </div>
                <div id="piano-debug" style="font-size: 0.7em; color: #999; margin-top: 5px;">Debug: Loading...</div>
            </div>
            
            <div class="expression-group vibrato">
                <div class="expression-group-title">Vibrato Parameters</div>
                <div class="control-group">
                    <label for="vibratoRate">Base Rate</label>
                    <input type="range" id="vibratoRate" value="5.0" min="0.0" max="10.0" step="0.1">
                    <span id="vibratoRateValue" class="value-display">5.0</span>
                </div>
                <div class="control-group" style="margin-top: 15px;">
                    <label>Vibrato Harmonic Ratios</label>
                    <div class="harmonic-selector" data-expression="vibrato">
                        <div class="harmonic-row" data-type="numerator">
                            <span class="harmonic-number" data-value="1">1</span>
                            <span class="harmonic-number" data-value="2">2</span>
                            <span class="harmonic-number" data-value="3">3</span>
                            <span class="harmonic-number" data-value="4">4</span>
                            <span class="harmonic-number" data-value="5">5</span>
                            <span class="harmonic-number" data-value="6">6</span>
                            <span class="harmonic-number" data-value="7">7</span>
                            <span class="harmonic-number" data-value="8">8</span>
                            <span class="harmonic-number" data-value="9">9</span>
                            <span class="harmonic-number" data-value="10">10</span>
                            <span class="harmonic-number" data-value="11">11</span>
                            <span class="harmonic-number" data-value="12">12</span>
                        </div>
                        <div class="harmonic-row" data-type="denominator">
                            <span class="harmonic-number" data-value="1">1</span>
                            <span class="harmonic-number" data-value="2">2</span>
                            <span class="harmonic-number" data-value="3">3</span>
                            <span class="harmonic-number" data-value="4">4</span>
                            <span class="harmonic-number" data-value="5">5</span>
                            <span class="harmonic-number" data-value="6">6</span>
                            <span class="harmonic-number" data-value="7">7</span>
                            <span class="harmonic-number" data-value="8">8</span>
                            <span class="harmonic-number" data-value="9">9</span>
                            <span class="harmonic-number" data-value="10">10</span>
                            <span class="harmonic-number" data-value="11">11</span>
                            <span class="harmonic-number" data-value="12">12</span>
                        </div>
                    </div>
                </div>

            </div>
            
            <div class="expression-group trill">
                <div class="expression-group-title">Trill Parameters</div>

                <div class="control-group">
                    <label for="trillArticulation">Articulation</label>
                    <input type="range" id="trillArticulation" value="0.7" min="0.1" max="0.95" step="0.01">
                    <span id="trillArticulationValue" class="value-display">0.70</span>
                </div>
                <div class="control-group">
                    <label for="trillSpeed">Speed</label>
                    <input type="range" id="trillSpeed" value="5.0" min="3.0" max="12.0" step="0.1">
                    <span id="trillSpeedValue" class="value-display">5.0</span>
                </div>
                <div class="control-group" style="margin-top: 15px;">
                    <label>Trill Harmonic Ratios</label>
                    <div class="harmonic-selector" data-expression="trill">
                        <div class="harmonic-row" data-type="numerator">
                            <span class="harmonic-number" data-value="1">1</span>
                            <span class="harmonic-number" data-value="2">2</span>
                            <span class="harmonic-number" data-value="3">3</span>
                            <span class="harmonic-number" data-value="4">4</span>
                            <span class="harmonic-number" data-value="5">5</span>
                            <span class="harmonic-number" data-value="6">6</span>
                            <span class="harmonic-number" data-value="7">7</span>
                            <span class="harmonic-number" data-value="8">8</span>
                            <span class="harmonic-number" data-value="9">9</span>
                            <span class="harmonic-number" data-value="10">10</span>
                            <span class="harmonic-number" data-value="11">11</span>
                            <span class="harmonic-number" data-value="12">12</span>
                        </div>
                        <div class="harmonic-row" data-type="denominator">
                            <span class="harmonic-number" data-value="1">1</span>
                            <span class="harmonic-number" data-value="2">2</span>
                            <span class="harmonic-number" data-value="3">3</span>
                            <span class="harmonic-number" data-value="4">4</span>
                            <span class="harmonic-number" data-value="5">5</span>
                            <span class="harmonic-number" data-value="6">6</span>
                            <span class="harmonic-number" data-value="7">7</span>
                            <span class="harmonic-number" data-value="8">8</span>
                            <span class="harmonic-number" data-value="9">9</span>
                            <span class="harmonic-number" data-value="10">10</span>
                            <span class="harmonic-number" data-value="11">11</span>
                            <span class="harmonic-number" data-value="12">12</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="expression-group tremolo">
                <div class="expression-group-title">Tremolo Parameters</div>
                <div class="control-group">
                    <label for="tremoloArticulation">Articulation</label>
                    <input type="range" id="tremoloArticulation" value="0.8" min="0.1" max="0.95" step="0.01">
                    <span id="tremoloArticulationValue" class="value-display">0.80</span>
                </div>

                <div class="control-group">
                    <label for="tremoloSpeed">Speed</label>
                    <input type="range" id="tremoloSpeed" value="4.0" min="1.0" max="12.0" step="0.1">
                    <span id="tremoloSpeedValue" class="value-display">4.0</span>
                </div>
                <div class="control-group" style="margin-top: 15px;">
                    <label>Tremolo Harmonic Ratios</label>
                    <div class="harmonic-selector" data-expression="tremolo">
                        <div class="harmonic-row" data-type="numerator">
                            <span class="harmonic-number" data-value="1">1</span>
                            <span class="harmonic-number" data-value="2">2</span>
                            <span class="harmonic-number" data-value="3">3</span>
                            <span class="harmonic-number" data-value="4">4</span>
                            <span class="harmonic-number" data-value="5">5</span>
                            <span class="harmonic-number" data-value="6">6</span>
                            <span class="harmonic-number" data-value="7">7</span>
                            <span class="harmonic-number" data-value="8">8</span>
                            <span class="harmonic-number" data-value="9">9</span>
                            <span class="harmonic-number" data-value="10">10</span>
                            <span class="harmonic-number" data-value="11">11</span>
                            <span class="harmonic-number" data-value="12">12</span>
                        </div>
                        <div class="harmonic-row" data-type="denominator">
                            <span class="harmonic-number" data-value="1">1</span>
                            <span class="harmonic-number" data-value="2">2</span>
                            <span class="harmonic-number" data-value="3">3</span>
                            <span class="harmonic-number" data-value="4">4</span>
                            <span class="harmonic-number" data-value="5">5</span>
                            <span class="harmonic-number" data-value="6">6</span>
                            <span class="harmonic-number" data-value="7">7</span>
                            <span class="harmonic-number" data-value="8">8</span>
                            <span class="harmonic-number" data-value="9">9</span>
                            <span class="harmonic-number" data-value="10">10</span>
                            <span class="harmonic-number" data-value="11">11</span>
                            <span class="harmonic-number" data-value="12">12</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        


    <div class="section">
            <div class="section-title">Instrument</div>
            <div class="controls">
                <div class="control-group">
                    <label for="bodyType">Body Type</label>
                    <select id="bodyType">
                        <option value="0">Violin</option>
                        <option value="1">Viola</option>
                        <option value="2">Cello</option>
                        <option value="3">Guitar</option>
                        <option value="4">None</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="stringMaterial">Material</label>
                    <select id="stringMaterial">
                        <option value="0">Steel</option>
                        <option value="1">Gut</option>
                        <option value="2">Nylon</option>
                        <option value="3">Wound</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="stringDamping">Damping</label>
                    <input type="range" id="stringDamping" value="0.5" min="0.01" max="0.99" step="0.01">
                    <span id="stringDampingValue" class="value-display">0.50</span>
                </div>
                <div class="control-group">
                    <label for="brightness">Brightness</label>
                    <input type="range" id="brightness" value="0.5" min="0.0" max="1.0" step="0.01">
                    <span id="brightnessValue" class="value-display">0.50</span>
                </div>
                <div class="control-group">
                    <label for="bodyResonance">Body Resonance</label>
                    <input type="range" id="bodyResonance" value="0.3" min="0.0" max="1.0" step="0.01">
                    <span id="bodyResonanceValue" class="value-display">0.30</span>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Bow Control</div>
            <div class="controls">
                <div class="control-group">
                    <label for="bowForce">Force</label>
                    <input type="range" id="bowForce" value="0.5" min="0.0" max="1.0" step="0.01">
                    <span id="bowForceValue" class="value-display">0.50</span>
                </div>
                <div class="control-group">
                    <label for="bowPosition">Position</label>
                    <input type="range" id="bowPosition" value="0.12" min="0.02" max="0.5" step="0.01">
                    <span id="bowPositionValue" class="value-display">0.12</span>
                </div>
                <div class="control-group">
                    <label for="bowSpeed">Speed</label>
                    <input type="range" id="bowSpeed" value="0.5" min="0.0" max="1.0" step="0.01">
                    <span id="bowSpeedValue" class="value-display">0.50</span>
                </div>
            </div>
        </div>



        <hr class="separator">
        
        <div class="section">
            <div class="section-title">Master Output</div>
            <div class="controls">
                <div class="control-group">
                    <label for="masterGain">Volume</label>
                    <input type="range" id="masterGain" value="0.5" min="0.0" max="1.0" step="0.01">
                    <span id="masterGainValue" class="value-display">0.50</span>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="power" checked> Power On/Off
                    </label>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        
        <hr class="separator">
        
        <div class="section">
            <div class="section-title">Program Banking</div>
            <div class="banking-controls">
                <label for="bank_selector">Bank:</label>
                <select id="bank_selector">
                    <option value="1">Bank 1 ⚪</option>
                    <option value="2">Bank 2 ⚪</option>
                    <option value="3">Bank 3 ⚪</option>
                    <option value="4">Bank 4 ⚪</option>
                    <option value="5">Bank 5 ⚪</option>
                </select>
                <button id="save_bank">Save</button>
                <button id="load_bank">Load</button>
            </div>
            <div style="font-size: 0.8em; color: #666; margin-top: 5px;">
                Banks store: Parameters + Harmonic Ratios + Chord + Expressions
            </div>
        </div>
        
        <div id="synths">
            <h3>Connected Synths</h3>
            <div id="synth_list">None connected</div>
        </div>
    </div>

    <script>
        const controller_id = `ctrl-${Math.random().toString(36).substr(2, 9)}`
        const peers = new Map()
        const other_controllers = new Set()
        let ws = null
        let heartbeat_interval = null
        let wake_lock = null
        let kicked = false
        let current_program = null
        const program_banks = new Map()
        
        // Harmonic ratio selector functionality
        let harmonicSelections = {
            'vibrato-numerator': new Set([1]),
            'vibrato-denominator': new Set([1]),
            'trill-numerator': new Set([1]),
            'trill-denominator': new Set([1]),
            'tremolo-numerator': new Set([1]),
            'tremolo-denominator': new Set([1])
        }
        
        // Load saved banks from localStorage
        function loadBanksFromStorage() {
            try {
                const saved = localStorage.getItem('string-assembly-banks')
                if (saved) {
                    const banksData = JSON.parse(saved)
                    Object.entries(banksData).forEach(([bankId, program]) => {
                        program_banks.set(parseInt(bankId), program)
                    })
                    console.log('Loaded banks from storage:', program_banks.size, 'banks')
                }
            } catch (e) {
                console.warn('Failed to load banks from storage:', e)
            }
        }
        
        // Save banks to localStorage
        function saveBanksToStorage() {
            try {
                const banksData = {}
                program_banks.forEach((program, bankId) => {
                    banksData[bankId] = program
                })
                localStorage.setItem('string-assembly-banks', JSON.stringify(banksData))
                console.log('Saved banks to storage')
            } catch (e) {
                console.warn('Failed to save banks to storage:', e)
            }
        }
        
        // WebRTC configuration
        let rtc_config = {
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        }
        
        // Fetch ICE servers from server
        async function fetch_ice_servers() {
            try {
                const response = await fetch('/ice-servers')
                const data = await response.json()
                rtc_config.iceServers = data.ice_servers
                console.log('ICE servers loaded:', rtc_config.iceServers)
            } catch (error) {
                console.error('Failed to fetch ICE servers, using defaults:', error)
                // Fall back to default STUN servers
                rtc_config.iceServers = [
                    { urls: "stun:stun.l.google.com:19302" },
                    { urls: "stun:stun1.l.google.com:19302" }
                ]
                console.log('Using default ICE servers:', rtc_config.iceServers)
            }
        }
        
        // UI elements
        const status_el = document.getElementById('status')
        const synth_list_el = document.getElementById('synth_list')
        const connected_count_el = document.getElementById('connected_count')
        const avg_latency_el = document.getElementById('avg_latency')
        
        // Parameter elements
        const param_elements = {}
        const param_ids = [
            'stringMaterial', 'stringDamping',
            'bowPosition', 'bowSpeed', 'bowForce', 'brightness',
            'vibratoRate', 'trillSpeed', 'trillArticulation',
            'tremoloSpeed', 'tremoloArticulation',
            'bodyType', 'bodyResonance', 'masterGain', 'volume'
        ]
        
        // Initialize parameter elements
        param_ids.forEach(id => {
            const input = document.getElementById(id)
            const value_display = document.getElementById(id + 'Value')
            if (input && value_display) {
                param_elements[id] = { input, value_display }
            }
        })
        
        // Expression controls (may not exist if using per-note expressions)
        const expression_radios = document.querySelectorAll('input[name="expression"]')
        const expression_groups = document.querySelectorAll('.expression-group')
        
        // Initialize WebSocket connection
        function connect_websocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
            const ws_url = `${protocol}//${window.location.host}/`
            
            ws = new WebSocket(ws_url)
            
            ws.addEventListener('open', () => {
                console.log('WebSocket connected')
                status_el.textContent = 'Connected'
                status_el.classList.add('connected')
                
                // Register as controller
                send_message({
                    type: 'register',
                    client_id: controller_id
                })
                
                // Start heartbeat
                heartbeat_interval = setInterval(() => {
                    send_message({ type: 'heartbeat' })
                }, 20000)
            })
            
            ws.addEventListener('message', async (event) => {
                await handle_message(JSON.parse(event.data))
            })
            
            ws.addEventListener('close', () => {
                console.log('WebSocket disconnected')
                status_el.textContent = 'Disconnected'
                status_el.classList.remove('connected')
                
                if (heartbeat_interval) {
                    clearInterval(heartbeat_interval)
                    heartbeat_interval = null
                }
                
                // Reconnect after delay
                setTimeout(connect_websocket, 2000)
            })
            
            ws.addEventListener('error', (error) => {
                console.error('WebSocket error:', error)
            })
        }
        
        function send_message(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message))
            }
        }
        
        async function handle_message(message) {
            if (message.type === 'controllers-list') {
                // Handle controller list (not needed for this client)
            } else if (message.type === 'controller-joined') {
                other_controllers.add(message.controller_id)
                update_controller_warning()
            } else if (message.type === 'controller-left') {
                other_controllers.delete(message.controller_id)
                update_controller_warning()
            } else if (message.type === 'announce') {
                other_controllers.add(message.sender_id)
                update_controller_warning()
            } else if (message.type === 'kicked') {
                kicked = true
                status_el.textContent = `Kicked by ${message.kicked_by}`
                status_el.classList.remove('connected')
            } else if (message.type === 'offer') {
                await handle_offer(message)
            } else if (message.type === 'answer') {
                await handle_answer(message)
            } else if (message.type === 'ice') {
                await handle_ice_candidate(message)
            }
        }
        
        async function handle_offer(message) {
            const synth_id = message.source
            console.log(`Received offer from ${synth_id}`)
            
            const pc = new RTCPeerConnection(rtc_config)
            const peer = {
                connection: pc,
                param_channel: null,
                command_channel: null,
                latency: null,
                last_ping: null,
                state: null
            }
            peers.set(synth_id, peer)
            
            // Handle ICE candidates
            pc.addEventListener('icecandidate', (event) => {
                if (event.candidate) {
                    send_message({
                        type: 'ice',
                        source: controller_id,
                        target: synth_id,
                        data: event.candidate
                    })
                }
            })
            
            // Handle data channels
            pc.addEventListener('datachannel', (event) => {
                const channel = event.channel
                
                if (channel.label === 'params') {
                    peer.param_channel = channel
                    
                    channel.addEventListener('open', () => {
                        console.log(`Param channel open to ${synth_id}`)
                        update_synth_list()
                        
                        // Start ping interval
                        const ping_interval = setInterval(() => {
                            if (channel.readyState === 'open') {
                                const timestamp = Date.now()
                                peer.last_ping = timestamp
                                channel.send(JSON.stringify({
                                    type: 'ping',
                                    timestamp: timestamp
                                }))
                            } else {
                                clearInterval(ping_interval)
                            }
                        }, 1000)
                    })
                    
                    channel.addEventListener('message', (event) => {
                        const data = JSON.parse(event.data)
                        if (data.type === 'pong') {
                            peer.latency = Date.now() - data.timestamp
                            peer.state = data.state || null
                            console.log(`Received pong from ${synth_id} with state:`, data.state)
                            update_synth_list()
                        } else if (data.type === 'request_program') {
                            // send current program to requesting synth
                            console.log(`Received program request from ${synth_id}`)
                            
                            // Note: Frequency is now set per-note via chord distribution
                            
                            console.log('Current program object:', current_program)
                            console.log('Current program has keys:', Object.keys(current_program || {}))
                            if (current_program && Object.keys(current_program).length > 0) {
                                channel.send(JSON.stringify({
                                    type: 'program',
                                    program: current_program
                                }))
                                console.log(`Sent current program to ${synth_id}:`, current_program)
                            } else {
                                console.log(`No program to send to ${synth_id} - creating default program`)
                                const default_program = get_current_program()
                                channel.send(JSON.stringify({
                                    type: 'program',
                                    program: default_program
                                }))
                                console.log(`Sent default program to ${synth_id}:`, default_program)
                            }
                        }
                    })
                    
                    channel.addEventListener('close', () => {
                        console.log(`Param channel closed to ${synth_id}`)
                        update_synth_list()
                    })
                } else if (channel.label === 'commands') {
                    peer.command_channel = channel
                    
                    channel.addEventListener('open', () => {
                        console.log(`Command channel open to ${synth_id}`)
                        update_synth_list()
                    })
                    
                    channel.addEventListener('close', () => {
                        console.log(`Command channel closed to ${synth_id}`)
                        update_synth_list()
                    })
                }
            })
            
            // Set remote description and create answer
            await pc.setRemoteDescription(message.data)
            const answer = await pc.createAnswer()
            await pc.setLocalDescription(answer)
            
            send_message({
                type: 'answer',
                source: controller_id,
                target: synth_id,
                data: answer
            })
        }
        
        async function handle_answer(message) {
            // Controllers don't initiate connections, so this shouldn't happen
            console.warn('Received unexpected answer message')
        }
        
        async function handle_ice_candidate(message) {
            const synth_id = message.source
            const peer = peers.get(synth_id)
            
            if (peer && peer.connection) {
                await peer.connection.addIceCandidate(message.data)
            }
        }
        
        function update_synth_list() {
            const synth_entries = Array.from(peers.entries())
            connected_count_el.textContent = synth_entries.filter(([id, peer]) => 
                peer.param_channel && peer.param_channel.readyState === 'open'
            ).length.toString()
            
            if (synth_entries.length === 0) {
                synth_list_el.innerHTML = "None connected"
            } else {
                synth_list_el.innerHTML = synth_entries.map(([id, peer]) => {
                    const param_state = peer.param_channel ? peer.param_channel.readyState : 'closed'
                    const command_state = peer.command_channel ? peer.command_channel.readyState : 'closed'
                    const connection_state = (param_state === 'open' && command_state === 'open') ? 'connected' : 
                                 (param_state === 'connecting' || command_state === 'connecting') ? 'connecting' : 'disconnected'
                    
                    const latency_text = peer.latency !== null ? `<span class="latency">${peer.latency}ms</span>` : ""
                    
                    // Build detailed state information
                    let state_details = ""
                    if (peer.state) {
                        const audio_status = peer.state.audio_enabled ? 'running' : 'disabled'
                        const synthesis_status = peer.state.joined ? 'joined' : 'calibrating'
                        
                        state_details = `
                            <div class="synth-details">
                                <span class="audio-state">Audio: ${audio_status}</span>
                                <span class="synthesis-state">Synth: ${synthesis_status}</span>
                            </div>`
                    }
                    
                    return `<div class="synth ${connection_state}">
                        <div class="synth-header">${id} [${connection_state}] ${latency_text}</div>
                        ${state_details}
                    </div>`
                }).join("")
            }
            
            // Update average latency
            const latencies = synth_entries.map(([id, peer]) => peer.latency).filter(l => l !== null)
            if (latencies.length > 0) {
                const avg = Math.round(latencies.reduce((a, b) => a + b, 0) / latencies.length)
                avg_latency_el.textContent = `${avg}ms`
            } else {
                avg_latency_el.textContent = '-'
            }
        }
        
        // Generate random harmonic ratio from selections for specific expression
        function getRandomHarmonicRatio(expression) {
            const numeratorKey = `${expression}-numerator`;
            const denominatorKey = `${expression}-denominator`;
            
            const numerators = Array.from(harmonicSelections[numeratorKey]);
            const denominators = Array.from(harmonicSelections[denominatorKey]);
            
            if (numerators.length === 0 || denominators.length === 0) {
                return 1.0; // Default ratio if no selections
            }
            
            const randomNumerator = numerators[Math.floor(Math.random() * numerators.length)];
            const randomDenominator = denominators[Math.floor(Math.random() * denominators.length)];
            
            return randomNumerator / randomDenominator;
        }

        // Distribute chord to connected synths
        function distribute_chord() {
            if (currentChord.length === 0) {
                alert('Please select at least one note in the chord')
                return
            }
            
            // Get all connected, audio-enabled synths
            const availableSynths = Array.from(peers.entries()).filter(([id, peer]) => 
                peer.param_channel && peer.param_channel.readyState === 'open'
            )
            
            if (availableSynths.length === 0) {
                alert('No synths connected')
                return
            }
            
            console.log(`Distributing chord [${currentChord.join(', ')}] to ${availableSynths.length} synths`)
            
            // Get base program (all parameters except frequency/expression)
            const baseProgram = get_current_program()
            
            // Get expressions for each note
            const expressions = svgExpression ? svgExpression.getAllExpressions() : {}
            
            // Distribute notes evenly across synths
            let sentCount = 0
            availableSynths.forEach(([synthId, peer], index) => {
                // Assign note in round-robin fashion
                const noteIndex = index % currentChord.length
                const assignedNote = currentChord[noteIndex]
                const assignedExpression = expressions[assignedNote] || { type: 'none' }
                
                // Create program for this synth
                const synthProgram = { ...baseProgram }
                
                // Set frequency
                const frequency = note_to_frequency(assignedNote.slice(0, -1), parseInt(assignedNote.slice(-1)))
                synthProgram.fundamentalFrequency = frequency
                
                // Apply expression for this note
                switch (assignedExpression.type) {
                    case 'vibrato':
                        synthProgram.vibratoEnabled = 1
                        // Apply random harmonic ratio to vibrato rate
                        const vibratoRatio = getRandomHarmonicRatio('vibrato');
                        synthProgram.vibratoRate = (synthProgram.vibratoRate || 4) * vibratoRatio;
                        // Use per-note depth from piano roll gesture
                        synthProgram.vibratoDepth = assignedExpression.depth || 0.01;
                        console.log(`${synthId} vibrato: ${synthProgram.vibratoRate.toFixed(2)}Hz (${vibratoRatio.toFixed(2)}x)`);
                        break
                    case 'tremolo':
                        synthProgram.tremoloEnabled = 1
                        // Apply random harmonic ratio to tremolo speed
                        const tremoloRatio = getRandomHarmonicRatio('tremolo');
                        synthProgram.tremoloSpeed = (synthProgram.tremoloSpeed || 10) * tremoloRatio;
                        // Use per-note depth from piano roll gesture
                        synthProgram.tremoloDepth = assignedExpression.depth || 0.3;
                        synthProgram.tremoloArticulation = synthProgram.tremoloArticulation || 0.8;
                        console.log(`${synthId} tremolo: ${synthProgram.tremoloSpeed.toFixed(2)}Hz (${tremoloRatio.toFixed(2)}x)`);
                        break
                    case 'trill':
                        synthProgram.trillEnabled = 1
                        // Apply random harmonic ratio to trill speed
                        const trillRatio = getRandomHarmonicRatio('trill');
                        synthProgram.trillSpeed = (synthProgram.trillSpeed || 8) * trillRatio;
                        // Use per-note interval from piano roll gesture
                        synthProgram.trillInterval = assignedExpression.interval || 2;
                        synthProgram.trillArticulation = synthProgram.trillArticulation || 0.7;
                        console.log(`${synthId} trill: ${synthProgram.trillSpeed.toFixed(2)}Hz (${trillRatio.toFixed(2)}x)`);
                        break
                    default:
                        synthProgram.vibratoEnabled = 0
                        synthProgram.tremoloEnabled = 0
                        synthProgram.trillEnabled = 0
                }
                
                // Send to synth
                peer.param_channel.send(JSON.stringify({
                    type: 'program',
                    program: synthProgram
                }))
                
                console.log(`${synthId}: ${assignedNote} (${frequency.toFixed(1)}Hz) - ${assignedExpression.type}`)
                sentCount++
            })
            
            console.log(`Distributed chord to ${sentCount} synths`)
        }
        
        // Get current program from UI (excluding frequency and expressions - those are handled by chord distribution)
        function get_current_program() {
            const program = {}
            
            param_ids.forEach(id => {
                const element = param_elements[id]
                if (element && element.input) {
                    const value = element.input.type === 'range' ? 
                        parseFloat(element.input.value) : 
                        element.input.value
                    program[id] = value
                }
            })
            
            return program
        }
        
        // Create example program with stochastic elements
        function create_example_program() {
            return {
                stringMaterial: { type: "choice", options: [0, 1, 2, 3] },
                stringDamping: { type: "uniform", min: 0.3, max: 0.7 },
                bowPosition: { type: "uniform", min: 0.08, max: 0.25 },
                bowSpeed: { type: "normal", mean: 0.6, std: 0.1 },
                bowForce: { type: "uniform", min: 0.3, max: 0.8 },
                brightness: { type: "uniform", min: 0.2, max: 0.8 },
                vibratoRate: { type: "uniform", min: 4.0, max: 7.0 },
                vibratoDepth: { type: "uniform", min: 0.0, max: 0.3 },
                bodyType: { type: "choice", options: [0, 1, 2] },
                bodyResonance: { type: "uniform", min: 0.1, max: 0.6 },
                masterGain: 0.5
            }
        }
        
        // Save program to bank
        function save_to_bank(bank_id) {
            // Get current UI state (the "recipe" for new synths)
            current_program = get_current_program()
            
            // Store harmonic selections (convert Sets to Arrays for JSON serialization)
            const harmonicSelectionsForSave = {}
            Object.keys(harmonicSelections).forEach(key => {
                harmonicSelectionsForSave[key] = Array.from(harmonicSelections[key])
            })
            
            const controllerState = {
                ...current_program,
                harmonicSelections: harmonicSelectionsForSave,
                chordNotes: currentChord ? [...currentChord] : [],
                expressions: svgExpression ? svgExpression.getAllExpressions() : {}
            }
            
            // Store controller state for new synths
            program_banks.set(bank_id, controllerState)
            
            // Tell each synth to save its own resolved parameter values
            peers.forEach((peer, id) => {
                if (peer.command_channel && peer.command_channel.readyState === 'open') {
                    peer.command_channel.send(JSON.stringify({
                        type: 'command',
                        name: 'save',
                        bank: bank_id
                    }))
                }
            })
            
            console.log(`✓ Saved controller state to bank ${bank_id}, told ${peers.size} synths to save their resolved values`)
                
            // Save to localStorage
            saveBanksToStorage()
                
            // Update bank selector display
            updateBankDisplay()
        }
        
        // Load program from bank
        function load_from_bank(bank_id) {
            console.log(`Loading from bank ${bank_id}...`)
            if (!program_banks.has(bank_id)) {
                console.warn(`Bank ${bank_id} not found`)
                return false
            }
            
            const saved_state = program_banks.get(bank_id)
            if (!saved_state) {
                console.warn(`Bank ${bank_id} has no data`)
                return false
            }
            
            console.log('Restoring controller state from bank:', saved_state)
            
            // Restore controller UI state
            param_ids.forEach(id => {
                if (saved_state[id] !== undefined) {
                    const element = param_elements[id]
                    if (element && element.input) {
                        element.input.value = saved_state[id]
                        update_display_value(id, saved_state[id])
                    }
                }
            })
            
            // Restore harmonic selections
            if (saved_state.harmonicSelections) {
                for (const key in saved_state.harmonicSelections) {
                    if (harmonicSelections[key] && Array.isArray(saved_state.harmonicSelections[key])) {
                        harmonicSelections[key].clear()
                        saved_state.harmonicSelections[key].forEach(value => {
                            harmonicSelections[key].add(value)
                        })
                    }
                }
            }
            
            // Restore chord and expressions
            if (saved_state.chordNotes && Array.isArray(saved_state.chordNotes)) {
                currentChord = [...saved_state.chordNotes]
                if (svgExpression) {
                    svgExpression.setChordNotes(currentChord)
                    if (saved_state.expressions) {
                        svgExpression.setMultipleExpressions(saved_state.expressions)
                    }
                }
            }
            
            current_program = saved_state
            
            // Tell each synth to load its own saved values (or generate new ones if it's new)
            peers.forEach((peer, id) => {
                if (peer.command_channel && peer.command_channel.readyState === 'open') {
                    peer.command_channel.send(JSON.stringify({
                        type: 'command',
                        name: 'load',
                        bank: bank_id,
                        fallbackProgram: get_current_program() // For new synths that don't have saved state
                    }))
                }
            })
            
            console.log(`✓ Restored controller state from bank ${bank_id}, told ${peers.size} synths to load their saved values`)
            return true
        }
        
        // Update UI display values
        function update_display_value(id, value) {
            const element = param_elements[id]
            if (element && element.value_display) {
                if (id === 'stringMaterial') {
                    const materials = ['Steel', 'Gut', 'Nylon', 'Wound']
                    element.value_display.textContent = materials[value] || materials[0]
                } else if (id === 'bodyType') {
                    const bodies = ['Violin', 'Viola', 'Cello', 'Guitar', 'None']
                    element.value_display.textContent = bodies[value] || bodies[0]
                } else if (id === 'trillInterval') {
                    const intervals = ['m2', 'M2', 'm3', 'M3', 'P4', 'TT', 'P5', 'm6', 'M6', 'm7', 'M7', '8va']
                    element.value_display.textContent = intervals[value - 1] || 'm2'
                } else if (typeof value === 'number') {
                    const decimals = value < 1 ? 2 : (value < 10 ? 1 : 0)
                    element.value_display.textContent = value.toFixed(decimals)
                } else {
                    element.value_display.textContent = value.toString()
                }
            }
        }
        
        // Update expression group visibility
        function update_expression_groups() {
            const expressionRadio = document.querySelector('input[name="expression"]:checked')
            if (!expressionRadio) {
                console.log('Expression radio buttons not found yet')
                return
            }
            
            const active_expression = expressionRadio.value
            expression_groups.forEach(group => {
                group.classList.remove('active')
            })
            
            if (active_expression !== 'none') {
                const active_group = document.querySelector(`.expression-group.${active_expression}`)
                if (active_group) {
                    active_group.classList.add('active')
                }
            }
        }
        
        function update_controller_warning() {
            const warning_el = document.getElementById('controller_warning')
            const other_controllers_el = document.getElementById('other_controllers')
            
            if (other_controllers.size > 0) {
                warning_el.classList.add('show')
                other_controllers_el.textContent = `Other controllers: ${Array.from(other_controllers).join(', ')}`
            } else {
                warning_el.classList.remove('show')
            }
        }
        
        // Event Listeners
        
        // Parameter input handlers (combined with change tracking)
        param_ids.forEach(id => {
            const element = param_elements[id]
            if (element && element.input) {
                element.input.addEventListener('input', (e) => {
                    const value = e.target.type === 'range' ? parseFloat(e.target.value) : e.target.value
                    update_display_value(id, value)
                    console.log('Combined input event fired for', id, 'new value:', value)
                    mark_parameter_changed(id)
                    check_overall_status()
                    // Update current program with new values
                    if (current_program) {
                        current_program[id] = value
                    }
                })
            }
        })
        
        // Expression radio handlers (only if they exist)
        if (expression_radios.length > 0) {
            expression_radios.forEach(radio => {
                radio.addEventListener('change', update_expression_groups)
            })
        }
        
        // Program control buttons
        document.getElementById('send_current_program').addEventListener('click', () => {
            update_status_badge('sending')
            distribute_chord()
            mark_all_parameters_sent()
            setTimeout(() => update_status_badge('synced'), 500)
        })
        
        // Banking controls
        document.getElementById('save_bank').addEventListener('click', (e) => {
            const bank_id = parseInt(document.getElementById('bank_selector').value)
            save_to_bank(bank_id)
            
            // Visual feedback
            e.target.classList.add('success')
            e.target.textContent = '✓ Saved'
            setTimeout(() => {
                e.target.classList.remove('success')
                e.target.textContent = 'Save'
            }, 1500)
            
            console.log(`✓ Program saved to Bank ${bank_id}`)
        })
        
        document.getElementById('load_bank').addEventListener('click', (e) => {
            const bank_id = parseInt(document.getElementById('bank_selector').value)
            const success = load_from_bank(bank_id)
            
            if (success) {
                // Visual feedback
                e.target.classList.add('success')
                e.target.textContent = '✓ Loaded'
                setTimeout(() => {
                    e.target.classList.remove('success')
                    e.target.textContent = 'Load'
                }, 1500)
                
                // Update harmonic displays after DOM is ready
                setTimeout(() => {
                    ['vibrato', 'trill', 'tremolo'].forEach(expression => {
                        ['numerator', 'denominator'].forEach(type => {
                            if (typeof updateHarmonicDisplay === 'function') {
                                updateHarmonicDisplay(expression, type)
                            }
                        })
                    })
                    if (typeof updateExpressionDisplay === 'function') {
                        updateExpressionDisplay()
                    }
                }, 100)
            } else {
                // Error feedback
                e.target.classList.add('error')
                e.target.textContent = '✗ Empty'
                setTimeout(() => {
                    e.target.classList.remove('error')
                    e.target.textContent = 'Load'
                }, 1500)
            }
        })
        
        // Power control
        document.getElementById('power').addEventListener('change', (e) => {
            const is_on = e.target.checked
            peers.forEach((peer, id) => {
                if (peer.command_channel && peer.command_channel.readyState === 'open') {
                    peer.command_channel.send(JSON.stringify({
                        type: 'command',
                        name: 'power',
                        value: is_on
                    }))
                }
            })
        })
        
        // Kick other controllers
        document.getElementById('kick_others').addEventListener('click', () => {
            send_message({
                type: 'kick-other-controllers'
            })
            other_controllers.clear()
            update_controller_warning()
        })
        
        // Initialize UI
        function initialize_ui() {
            // Set initial display values
            param_ids.forEach(id => {
                const element = param_elements[id]
                if (element && element.input) {
                    const value = element.input.type === 'range' ? 
                        parseFloat(element.input.value) : 
                        element.input.value
                    update_display_value(id, value)
                }
            })
            
            // Initialize expression groups
            update_expression_groups()
        
            // Initialize piano GUI
            initialize_piano()
            
            // Initialize parameter change tracking
            initialize_parameter_tracking()
            
            // Initialize harmonic selectors
            initializeHarmonicSelectors()
        }

        // Piano GUI functions
        function calculate_ranges() {
            return {
                0: { name: 'Violin', low: note_to_frequency('G', 3), high: note_to_frequency('A', 7) },     // G3 to A7
                1: { name: 'Viola', low: note_to_frequency('C', 3), high: note_to_frequency('E', 6) },     // C3 to E6
                2: { name: 'Cello', low: note_to_frequency('C', 2), high: note_to_frequency('C', 6) },     // C2 to C6
                3: { name: 'Guitar', low: note_to_frequency('E', 3), high: note_to_frequency('E', 6) },    // E3 to E6
                4: { name: 'None', low: note_to_frequency('A', 1), high: note_to_frequency('C', 8) }       // A1 to C8
            }
        }
        
        const instrument_ranges = calculate_ranges()

        function note_to_frequency(note, octave) {
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
            // A4 = 440Hz is note number 69 in MIDI (A4 = 4*12 + 9 = 57, but we need A4=69)
            // Calculate semitones from A4
            const note_index = notes.indexOf(note)
            const semitones_from_a4 = (octave - 4) * 12 + (note_index - 9)
            return 440 * Math.pow(2, semitones_from_a4 / 12)
        }

        function frequency_to_note(freq) {
            // Calculate semitones from A4 (440Hz)
            const semitones_from_a4 = Math.round(12 * Math.log2(freq / 440))
            
            // A4 is octave 4, note index 9 (A)
            const total_semitones = semitones_from_a4 + (4 * 12) + 9
            const octave = Math.floor(total_semitones / 12)
            const note_index = ((total_semitones % 12) + 12) % 12
            
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
            return { note: notes[note_index], octave: octave }
        }

        function initialize_piano() {
            const piano = document.getElementById('piano')
            const bodyType = parseInt(document.getElementById('bodyType').value)
            draw_piano_keys(bodyType)
            update_piano_range_display(bodyType)
        
            // Update piano when body type changes
            document.getElementById('bodyType').addEventListener('change', (e) => {
                const newBodyType = parseInt(e.target.value)
                draw_piano_keys(newBodyType)
                update_piano_range_display(newBodyType)
            })
        }

        function draw_piano_keys(bodyType) {
            const piano = document.getElementById('piano')
            const range = instrument_ranges[bodyType]
            
            console.log('Drawing piano keys for bodyType:', bodyType, 'range:', range)
            
            // Debug: Test a few known frequencies
            console.log('Test frequencies:')
            console.log('G3 (violin low):', note_to_frequency('G', 3), 'expected: 196, in range?', note_to_frequency('G', 3) >= range.low && note_to_frequency('G', 3) <= range.high)
            console.log('F#3 (below violin):', note_to_frequency('F#', 3), 'in range?', note_to_frequency('F#', 3) >= range.low && note_to_frequency('F#', 3) <= range.high)
            console.log('A4 (440Hz):', note_to_frequency('A', 4), 'in range?', note_to_frequency('A', 4) >= range.low && note_to_frequency('A', 4) <= range.high)
            console.log('Range:', range.low, 'to', range.high)
            
            // Clear existing keys
            piano.innerHTML = ''
            
            // Define full piano range
            const start_octave = 2
            const end_octave = 7
            const white_keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
            const key_width = 16
            const white_key_height = 60
            const black_key_height = 35
            
            let key_count = 0
            let white_key_x = 0
            
            // Draw white keys first
            for (let octave = start_octave; octave <= end_octave; octave++) {
                for (let note of white_keys) {
                    const freq = note_to_frequency(note, octave)
                    const in_range = freq >= range.low && freq <= range.high
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
                    rect.setAttribute('x', white_key_x)
                    rect.setAttribute('y', 10)
                    rect.setAttribute('width', key_width)
                    rect.setAttribute('height', white_key_height)
                    rect.setAttribute('fill', in_range ? 'white' : '#f5f5f5')
                    rect.setAttribute('stroke', '#333')
                    rect.setAttribute('stroke-width', '1')
                    rect.setAttribute('data-note', note)
                    rect.setAttribute('data-octave', octave)
                    rect.setAttribute('data-freq', freq.toFixed(1))
                    
                    if (in_range) {
                        rect.style.cursor = 'pointer'
                        rect.addEventListener('click', () => select_frequency(freq))
                        rect.addEventListener('mouseenter', () => {
                            // Don't change hover color if it's managed by SVG expression system
                            if (!rect.hasAttribute('data-original-fill')) {
                                rect.setAttribute('fill', '#e6f3ff')
                            }
                        })
                        rect.addEventListener('mouseleave', () => {
                            // Don't change hover color if it's managed by SVG expression system
                            if (!rect.hasAttribute('data-original-fill')) {
                                rect.setAttribute('fill', 'white')
                            }
                        })
                    }
                    
                    piano.appendChild(rect)
                    key_count++
                    white_key_x += key_width
                }
            }
            
            // Draw black keys on top
            white_key_x = 0
            for (let octave = start_octave; octave <= end_octave; octave++) {
                for (let i = 0; i < white_keys.length; i++) {
                    const note = white_keys[i]
                    
                    // Check if there's a black key after this white key
                    let black_note = null
                    if (note === 'C') black_note = 'C#'
                    else if (note === 'D') black_note = 'D#'
                    else if (note === 'F') black_note = 'F#'
                    else if (note === 'G') black_note = 'G#'
                    else if (note === 'A') black_note = 'A#'
                    
                    if (black_note) {
                        const freq = note_to_frequency(black_note, octave)
                        const in_range = freq >= range.low && freq <= range.high
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
                        rect.setAttribute('x', white_key_x + key_width - 6)
                        rect.setAttribute('y', 10)
                        rect.setAttribute('width', 12)
                        rect.setAttribute('height', black_key_height)
                        rect.setAttribute('fill', in_range ? '#333' : '#ccc')
                        rect.setAttribute('stroke', '#000')
                        rect.setAttribute('stroke-width', '1')
                        rect.setAttribute('data-note', black_note)
                        rect.setAttribute('data-octave', octave)
                        rect.setAttribute('data-freq', freq.toFixed(1))
                        
                        if (in_range) {
                            rect.style.cursor = 'pointer'
                            rect.addEventListener('click', () => select_frequency(freq))
                            rect.addEventListener('mouseenter', () => {
                                // Don't change hover color if it's managed by SVG expression system
                                if (!rect.hasAttribute('data-original-fill')) {
                                    rect.setAttribute('fill', '#555')
                                }
                            })
                            rect.addEventListener('mouseleave', () => {
                                // Don't change hover color if it's managed by SVG expression system
                                if (!rect.hasAttribute('data-original-fill')) {
                                    rect.setAttribute('fill', '#333')
                                }
                            })
                        }
                        
                        piano.appendChild(rect)
                        key_count++
                    }
                    
                    white_key_x += key_width
                }
            }
            
            console.log('Created', key_count, 'piano keys')
            document.getElementById('piano-debug').textContent = `Debug: Created ${key_count} keys`
            
            // Highlight current frequency
            setTimeout(() => highlight_current_frequency(), 100)
            
            // Try to initialize SVG expression now that piano is ready
            if (typeof initializeSVGExpression === 'function') {
                initializeSVGExpression();
            }
        }

        function update_piano_range_display(bodyType) {
            const range = instrument_ranges[bodyType]
            const low_note = frequency_to_note(range.low)
            const high_note = frequency_to_note(range.high)
            console.log('Range display - low freq:', range.low, 'high freq:', range.high)
            console.log('Range display - low note:', low_note, 'high note:', high_note)
            document.getElementById('piano-range-display').textContent = 
                `Range: ${low_note.note}${low_note.octave}-${high_note.note}${high_note.octave} (${range.name})`
        }

        function select_frequency(freq) {
            // Find the note name from frequency
            const noteData = frequency_to_note(freq);
            const noteName = `${noteData.note}${noteData.octave}`;
            
            console.log('Piano key clicked:', noteName, freq);
            
            // Let the expression system handle chord membership
            // It will trigger handleExpressionChange which will sync the chord
            console.log('Piano key clicked, letting expression system handle:', noteName);
            
            console.log('Current chord:', currentChord);
            
            // Update chord display with trill targets in brackets
            const chordDisplay = document.getElementById('chord-display');
            if (chordDisplay && svgExpression) {
                if (currentChord.length > 0) {
                    const expressions = svgExpression.getAllExpressions();
                    const processedNotes = new Set();
                    const chordParts = [];
                    
                    currentChord.forEach(note => {
                        if (processedNotes.has(note)) return;
                        
                        const expr = expressions[note];
                        if (expr && expr.type === 'trill' && expr.targetNote) {
                            // Show trill with target in brackets
                            chordParts.push(`${note} (→${expr.targetNote})`);
                            processedNotes.add(note);
                            processedNotes.add(expr.targetNote);
                        } else {
                            // Check if this is a trill target
                            let isTrillTarget = false;
                            for (const [otherNote, otherExpr] of Object.entries(expressions)) {
                                if (otherExpr && otherExpr.type === 'trill' && otherExpr.targetNote === note) {
                                    isTrillTarget = true;
                                    break;
                                }
                            }
                            if (!isTrillTarget) {
                                chordParts.push(note);
                                processedNotes.add(note);
                            }
                        }
                    });
                    
                    chordDisplay.textContent = chordParts.join(' ');
                } else {
                    chordDisplay.textContent = 'None';
                }
            }
            
            // Update SVG expression system
            if (svgExpression) {
                console.log('Updating SVG expression system with chord notes');
                svgExpression.setChordNotes(currentChord);
                
                // Force a re-render
                setTimeout(() => {
                    svgExpression.render();
                }, 10);
            } else {
                console.log('Warning: svgExpression not initialized yet - will update when ready');
                // Store chord for when expression system is ready
                window.pendingChordUpdate = currentChord;
            }
            updateExpressionDisplay();
        }

        function highlight_current_frequency() {
            // Note: This function is no longer used since frequency is set per-note
            // Kept for compatibility but does nothing
            return;
        }

        // harmonicSelections moved to top of script
        
        function initializeHarmonicSelectors() {
            const selectors = document.querySelectorAll('.harmonic-selector');
            
            // Set initial display for default selections
            ['vibrato', 'trill', 'tremolo'].forEach(expression => {
                ['numerator', 'denominator'].forEach(type => {
                    updateHarmonicDisplay(expression, type);
                });
            });
            
            selectors.forEach(selector => {
                const expression = selector.dataset.expression;
                
                ['numerator', 'denominator'].forEach(type => {
                    const row = selector.querySelector(`[data-type="${type}"]`);
                    if (!row) return;
                
                let isSelecting = false;
                let startValue = null;
                
                const numbers = row.querySelectorAll('.harmonic-number');
                
                numbers.forEach(number => {
                    let dragStarted = false;
                    
                    // Mouse down - prepare for potential drag
                    number.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        dragStarted = false;
                        isSelecting = true;
                        startValue = parseInt(number.dataset.value);
                    });
                    
                    // Mouse enter during drag
                    number.addEventListener('mouseenter', (e) => {
                        if (isSelecting && startValue !== null) {
                            if (!dragStarted) {
                                dragStarted = true;
                                clearHarmonicSelection(expression, type);
                            }
                            const currentValue = parseInt(number.dataset.value);
                            clearHarmonicSelection(expression, type);
                            selectHarmonicRange(expression, type, startValue, currentValue);
                        }
                    });
                    
                    // Click to toggle (only if no drag occurred)
                    number.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (!dragStarted) {
                            const value = parseInt(number.dataset.value);
                            toggleHarmonicValue(expression, type, value);
                        }
                    });
                });
                
                // Mouse up to end selection
                document.addEventListener('mouseup', () => {
                    if (isSelecting) {
                        isSelecting = false;
                        startValue = null;
                        // Remove selecting class from all numbers
                        numbers.forEach(n => n.classList.remove('selecting'));
                        updateHarmonicDisplay(expression, type);
                    }
                    });
                });
            });
        }
        
        function toggleHarmonicValue(expression, type, value) {
            const key = `${expression}-${type}`;
            const selection = harmonicSelections[key];
            if (selection.has(value)) {
                selection.delete(value);
            } else {
                selection.add(value);
            }
            updateHarmonicDisplay(expression, type);
        }
        
        function selectHarmonicValue(expression, type, value) {
            const key = `${expression}-${type}`;
            harmonicSelections[key].add(value);
            updateHarmonicDisplay(expression, type);
        }
        
        function selectHarmonicRange(expression, type, start, end) {
            const min = Math.min(start, end);
            const max = Math.max(start, end);
            const key = `${expression}-${type}`;
            const selection = harmonicSelections[key];
            
            for (let i = min; i <= max; i++) {
                selection.add(i);
            }
            updateHarmonicDisplay(expression, type);
        }
        
        function clearHarmonicSelection(expression, type) {
            const key = `${expression}-${type}`;
            harmonicSelections[key].clear();
            updateHarmonicDisplay(expression, type);
        }
        
        function updateHarmonicDisplay(expression, type) {
            const selector = document.querySelector(`[data-expression="${expression}"]`);
            if (!selector) return;
            
            const row = selector.querySelector(`[data-type="${type}"]`);
            if (!row) return;
            
            const numbers = row.querySelectorAll('.harmonic-number');
            const key = `${expression}-${type}`;
            const selection = harmonicSelections[key];
            
            numbers.forEach(number => {
                const value = parseInt(number.dataset.value);
                if (selection.has(value)) {
                    number.classList.add('selected');
                } else {
                    number.classList.remove('selected');
                }
            });
            
            console.log(`${key}:`, Array.from(selection).sort((a, b) => a - b));
        }
        
        function updateBankDisplay() {
            const selector = document.getElementById('bank_selector');
            for (let i = 1; i <= 5; i++) {
                const option = selector.querySelector(`option[value="${i}"]`);
                if (option) {
                    const hasData = program_banks.has(i);
                    const baseText = `Bank ${i}`;
                    option.textContent = hasData ? `${baseText} ●` : `${baseText} ⚪`;
                }
            }
        }
        
        // Start the application
        async function start_controller() {
            await fetch_ice_servers()
            initialize_ui()
            connect_websocket()
            // Load saved banks
            loadBanksFromStorage()
            
            // Initialize current program with UI state
            current_program = get_current_program()
            
            // Update bank display
            updateBankDisplay()
        }

        // Parameter change tracking
        let sent_program_state = {}
        
        function initialize_parameter_tracking() {
            // Store initial state as "sent"
            sent_program_state = get_current_program()
            update_status_badge('synced')
            
            // Add listeners to expression radios (parameters already handled above)
            const expressionRadios = document.querySelectorAll('input[name="expression"]')
            if (expressionRadios.length > 0) {
                expressionRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        console.log('Expression radio changed to:', radio.value)
                        mark_parameter_changed('expression')
                        check_overall_status()
                    })
                })
            }
        }
        
        function mark_parameter_changed(param_id) {
            console.log('Marking parameter changed:', param_id)
            
            // Find the control group for this parameter
            let control_group = null
            
            if (param_id === 'expression') {
                const expressionRadio = document.querySelector('input[name="expression"]')
                if (expressionRadio) {
                    control_group = expressionRadio.closest('.control-group')
                }
            } else {
                const element = param_elements[param_id]
                if (element && element.input) {
                    control_group = element.input.closest('.control-group')
                }
            }
            
            if (control_group) {
                control_group.classList.remove('sent')
                control_group.classList.add('changed')
                console.log('Added changed class to', param_id)
            } else {
                console.log('Could not find control group for', param_id)
            }
        }
        
        function mark_all_parameters_sent() {
            // Remove changed class and briefly add sent class to all parameters
            param_ids.forEach(id => {
                const element = param_elements[id]
                if (element && element.input) {
                    const control_group = element.input.closest('.control-group')
                    if (control_group) {
                        control_group.classList.remove('changed')
                        control_group.classList.add('sent')
                        setTimeout(() => {
                            control_group.classList.remove('sent')
                        }, 1000)
                    }
                }
            })
            
            // Handle expression group (if it exists)
            const expressionRadio = document.querySelector('input[name="expression"]')
            if (expressionRadio) {
                const expressionGroup = expressionRadio.closest('.control-group')
                if (expressionGroup) {
                    expressionGroup.classList.remove('changed')
                    expressionGroup.classList.add('sent')
                    setTimeout(() => {
                        expressionGroup.classList.remove('sent')
                    }, 1000)
                }
            }
            
            // Update sent state
            sent_program_state = get_current_program()
        }
        
        function check_overall_status() {
            const current_state = get_current_program()
            const has_changes = JSON.stringify(current_state) !== JSON.stringify(sent_program_state)
            
            if (has_changes) {
                update_status_badge('pending')
            } else {
                update_status_badge('synced')
            }
        }
        
        function update_status_badge(status) {
            const badge = document.getElementById('status_badge')
            badge.className = `status-badge ${status}`
            
            switch(status) {
                case 'synced':
                    badge.textContent = '✓ Synced'
                    break
                case 'pending':
                    badge.textContent = '● Changes Pending'
                    break
                case 'sending':
                    badge.textContent = '📡 Sending...'
                    break
            }
        }

        // Start when page loads
        start_controller()
    </script>
    
    <!-- Include interactive expression and stochastic chord modules -->
    <script src="svg_interactive_expression.js"></script>
    <script src="stochastic_chords.js"></script>
    <script src="standard_parameters.js"></script>
    
    <script>
        // Initialize chord and expression system
        let svgExpression = null;
        let chordDistributor = new StochasticChordDistributor();
        let currentChord = [];
        
        // Initialize SVG interactive expression when piano is ready
        function initializeSVGExpression() {
            const piano = document.getElementById('piano');
            if (piano && piano.querySelectorAll('rect').length > 0) {
                svgExpression = new SVGInteractiveExpression(piano);
                svgExpression.onExpressionChange = handleExpressionChange;
                console.log('SVG Interactive expression system initialized');
                
                // If chord already exists, update the expression system
                if (currentChord.length > 0) {
                    svgExpression.setChordNotes(currentChord);
                }
                
                // Check for pending chord update
                if (window.pendingChordUpdate) {
                    svgExpression.setChordNotes(window.pendingChordUpdate);
                    delete window.pendingChordUpdate;
                }
                return true;
            }
            return false;
        }
        
        // Try to initialize immediately, then retry if needed
        if (!initializeSVGExpression()) {
            const initInterval = setInterval(() => {
                if (initializeSVGExpression()) {
                    clearInterval(initInterval);
                }
            }, 100);
        }
        
        function handleExpressionChange(note, expression) {
            console.log('Expression change:', note, expression);
            
            // Sync chord array with expression system
            if (svgExpression) {
                const chordNotes = svgExpression.getChordNotes();
                currentChord = chordNotes.sort((a, b) => {
                    const freqA = note_to_frequency(a.slice(0, -1), parseInt(a.slice(-1)));
                    const freqB = note_to_frequency(b.slice(0, -1), parseInt(b.slice(-1)));
                    return freqA - freqB;
                });
                console.log('Updated chord from expression system:', currentChord);
            }
            
            updateExpressionDisplay();
            updateExpressionGroups();
        }
        
        function updateExpressionDisplay() {
            const content = document.getElementById('expression-content');
            const chordDisplay = document.getElementById('chord-display');
            if (!content) return;
            
            // Update chord display with trill targets in brackets
            if (chordDisplay) {
                if (currentChord.length > 0) {
                    const expressions = svgExpression ? svgExpression.getAllExpressions() : {};
                    const processedNotes = new Set();
                    const chordParts = [];
                    
                    currentChord.forEach(note => {
                        if (processedNotes.has(note)) return;
                        
                        const expr = expressions[note];
                        if (expr && expr.type === 'trill' && expr.targetNote) {
                            // Show trill with target in brackets
                            chordParts.push(`${note} (→${expr.targetNote})`);
                            processedNotes.add(note);
                            processedNotes.add(expr.targetNote);
                        } else {
                            // Check if this is a trill target
                            let isTrillTarget = false;
                            for (const [otherNote, otherExpr] of Object.entries(expressions)) {
                                if (otherExpr && otherExpr.type === 'trill' && otherExpr.targetNote === note) {
                                    isTrillTarget = true;
                                    break;
                                }
                            }
                            if (!isTrillTarget) {
                                chordParts.push(note);
                                processedNotes.add(note);
                            }
                        }
                    });
                    
                    chordDisplay.textContent = chordParts.join(' ');
                } else {
                    chordDisplay.textContent = 'None';
                }
            }
            
            if (!svgExpression) {
                content.innerHTML = '<div style="color: #666; font-style: italic;">Loading expression system...</div>';
                return;
            }
            
            const expressions = svgExpression.getAllExpressions();
            const activeExpressions = Object.entries(expressions);
            
            if (activeExpressions.length === 0) {
                content.innerHTML = '<div style="color: #666; font-style: italic;">Click piano keys to add notes to chord</div>';
                return;
            }
            
            // Group notes by trill relationships
            const processedNotes = new Set();
            const displayItems = [];
            
            activeExpressions.forEach(([note, expression]) => {
                if (processedNotes.has(note)) return;
                
                let exprText = '';
                let className = 'note-expression';
                
                switch (expression.type) {
                    case 'vibrato':
                        exprText = `${note}: Vibrato (depth: ${(expression.depth * 100).toFixed(0)}%)`;
                        className += ' vibrato';
                        break;
                    case 'tremolo':
                        exprText = `${note}: Tremolo (depth: ${(expression.depth * 100).toFixed(0)}%)`;
                        className += ' tremolo';
                        break;
                    case 'trill':
                        exprText = `${note}: Trill`;
                        className += ' trill';
                        // Add trill target in brackets with styled arrow
                        if (expression.targetNote) {
                            exprText += ` <span style="opacity: 0.7; font-size: 0.9em;">(→ ${expression.targetNote})</span>`;
                            processedNotes.add(expression.targetNote);
                        }
                        break;
                    default:
                        // Check if this note is a trill target for another note
                        let isTrillTarget = false;
                        for (const [otherNote, otherExpr] of activeExpressions) {
                            if (otherExpr.type === 'trill' && otherExpr.targetNote === note) {
                                isTrillTarget = true;
                                break;
                            }
                        }
                        if (!isTrillTarget) {
                            exprText = `${note}`;
                            className += ' none';
                        }
                        break;
                }
                
                if (exprText) {
                    displayItems.push(`<div class="${className}">${exprText}</div>`);
                }
                processedNotes.add(note);
            });
            
            content.innerHTML = displayItems.join('');
        }
        
        // Update expression group visibility based on what's in use
        function updateExpressionGroups() {
            if (!svgExpression) return;
            
            const expressions = svgExpression.getAllExpressions();
            const activeTypes = new Set();
            
            // Find which expression types are in use
            Object.values(expressions).forEach(expr => {
                if (expr.type !== 'none') {
                    activeTypes.add(expr.type);
                }
            });
            
            // Show/hide expression groups
            const vibratoGroup = document.querySelector('.expression-group.vibrato');
            const trillGroup = document.querySelector('.expression-group.trill');
            const tremoloGroup = document.querySelector('.expression-group.tremolo');
            
            if (vibratoGroup) {
                vibratoGroup.classList.toggle('active', activeTypes.has('vibrato'));
            }
            if (trillGroup) {
                trillGroup.classList.toggle('active', activeTypes.has('trill'));
            }
            if (tremoloGroup) {
                tremoloGroup.classList.toggle('active', activeTypes.has('tremolo'));
            }
        }
        

        

    </script>
</body>
</html>