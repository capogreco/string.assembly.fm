<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>String Assembly FM - Controller</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            text-shadow: none;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }
        
        .section {
            margin-bottom: 25px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .section-title {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 8px;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .control-group {
            display: grid;
            grid-template-columns: 1fr 2fr 80px;
            gap: 15px;
            align-items: center;
        }
        
        label {
            font-weight: 500;
            color: #34495e;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            transition: background 0.3s;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
        }
        
        select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            background: white;
        }
        
        .value-display {
            font-family: monospace;
            font-size: 0.9em;
            color: #666;
            text-align: right;
            min-width: 60px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(102, 126, 234, 0.4);
        }
        
        button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        #status {
            text-align: center;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 20px;
            font-weight: 500;
            background: #e74c3c;
            color: white;
        }
        
        #status.connected {
            background: #27ae60;
        }
        
        #stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            padding: 15px;
            background: #ecf0f1;
            border-radius: 6px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat strong {
            display: block;
            font-size: 1.2em;
            color: #2c3e50;
        }
        
        hr.separator {
            border: none;
            height: 2px;
            background: linear-gradient(to right, transparent, #667eea, transparent);
            margin: 25px 0;
        }
        
        .expression-group {
            margin-top: 15px;
            padding: 15px;
            background: #fff;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            display: none;
        }
        
        .expression-group.active {
            display: block;
        }
        
        .expression-group.vibrato {
            border-left: 4px solid #3498db;
        }
        
        .expression-group.trill {
            border-left: 4px solid #e67e22;
        }
        
        .expression-group.tremolo {
            border-left: 4px solid #d35400;
        }
        
        .expression-group-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .expression-group.vibrato .expression-group-title {
            color: #3498db;
        }
        
        .expression-group.trill .expression-group-title {
            color: #e67e22;
        }
        
        .expression-group.tremolo .expression-group-title {
            color: #d35400;
        }
        
        .program-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .program-controls button {
            flex: 1;
            padding: 10px 16px;
            font-size: 0.9em;
        }
        
        .banking-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 15px;
        }
        
        .banking-controls select {
            flex: 1;
        }
        
        .banking-controls button {
            padding: 8px 16px;
            font-size: 0.9em;
        }
        
        #synths {
            background: #f8f9fa;
            border-radius: 6px;
            padding: 15px;
            margin-top: 20px;
        }
        
        #synths h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .synth {
            padding: 8px 12px;
            margin: 5px 0;
            background: white;
            border-radius: 4px;
            border-left: 4px solid #27ae60;
        }
        
        .synth.connecting {
            border-left-color: #f39c12;
        }
        
        .synth.disconnected {
            border-left-color: #e74c3c;
        }
        
        .latency {
            float: right;
            font-size: 0.8em;
            color: #666;
        }
        
        .synth-header {
            font-weight: bold;
            margin-bottom: 4px;
        }
        
        .synth-details {
            font-size: 0.85em;
            color: #555;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 4px;
        }
        
        .synth-details span {
            padding: 2px 6px;
            border-radius: 3px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
        }
        
        .audio-state {
            border-color: #28a745 !important;
            background: #d4edda !important;
        }
        

        
        .synthesis-state {
            border-color: #17a2b8 !important;
            background: #d1ecf1 !important;
        }
        

        

        
        .audio-off {
            color: #e74c3c;
            font-size: 0.8em;
        }
        
        .warning {
            background: #ff9800;
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            display: none;
        }
        
        .warning.show {
            display: block;
        }
        
        /* Parameter change indicators */
        .control-group.changed {
            position: relative;
        }
        
        .control-group.changed::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 2px solid #ff9800;
            border-radius: 6px;
            pointer-events: none;
            animation: pulse-orange 2s infinite;
        }
        
        .control-group.sent {
            position: relative;
        }
        
        .control-group.sent::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border: 2px solid #4caf50;
            border-radius: 6px;
            pointer-events: none;
            animation: fade-green 1s ease-out forwards;
        }
        
        @keyframes pulse-orange {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }
        
        @keyframes fade-green {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Status indicator */
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }
        
        .status-badge.synced {
            background: #4caf50;
            color: white;
        }
        
        .status-badge.pending {
            background: #ff9800;
            color: white;
            animation: pulse-orange 2s infinite;
        }
        
        .status-badge.sending {
            background: #2196f3;
            color: white;
        }
        
        /* Chord and Expression Control Styles */
        .chord-control {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .expression-display {
            margin-top: 15px;
            padding: 15px;
            background: #f0f0f0;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        .note-expression {
            display: inline-block;
            margin: 5px;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: 500;
            line-height: 1.4;
        }
        
        .note-expression.vibrato {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
        }
        
        .note-expression.tremolo {
            background: #fff3cd;
            color: #664d03;
            border: 1px solid #ffecb5;
        }
        
        .note-expression.trill {
            background: #cfe2ff;
            color: #0842a0;
            border: 1px solid #b6d4fe;
        }
        
        .note-expression.none {
            background: #e8daef;
            color: #6c3483;
            border: 1px solid #d2b4de;
        }
        
        /* Piano keyboard wrapper for interactive expressions */
        .piano-keyboard {
            position: relative;
            display: inline-block;
        }
        
        .piano-keyboard canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Gesture hint styles */
        .gesture-hint {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>String Assembly FM - Controller</h1>
        
        <div id="status">Disconnected</div>
        
        <div id="stats">
            <div class="stat">
                <strong id="connected_count">0</strong>
                <span>Connected</span>
            </div>
            <div class="stat">
                <strong id="avg_latency">-</strong>
                <span>Avg Latency</span>
            </div>
        </div>
        
        <div id="controller_warning" class="warning">
            ‚ö†Ô∏è Controller conflict detected - multiple controllers detected!
            <div id="other_controllers" style="font-size: 0.9em; margin-top: 5px;"></div>
            <button id="kick_others" style="margin-top: 10px; padding: 5px 15px; background: #d32f2f; color: white; border: none; border-radius: 3px; cursor: pointer;">Kick Other Controllers</button>
        </div>
        
        <div class="program-controls">
            <button id="send_current_program">Send Current Program</button>
            <span id="status_badge" class="status-badge synced">‚úì Synced</span>
        </div>
        
        <div class="section">
            <div class="section-title">Chord & Expression Control</div>
            
            <div style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; font-size: 0.9em; color: #666;">
                Click piano keys to add/remove notes from chord
            </div>
            
            <div class="section-title">Piano</div>
            <div id="piano-container" style="margin: 10px 0;">
                <svg id="piano" width="750" height="80" style="border: 1px solid #ddd; border-radius: 4px; background: #fafafa;" xmlns="http://www.w3.org/2000/svg">
                    <!-- Piano keys will be generated by JavaScript -->
                </svg>
                <div style="font-size: 0.8em; color: #666; margin-top: 5px; text-align: center;">
                    <span id="piano-range-display">Range: C4-C6 (Violin)</span>
                </div>
                <div id="piano-debug" style="font-size: 0.7em; color: #999; margin-top: 5px;">Debug: Loading...</div>
            </div>
            
            <div style="margin-top: 10px; padding: 10px; background: #e9ecef; border-radius: 6px; font-size: 0.9em;">
                <strong>üéµ Gesture Controls:</strong><br>
                ‚Üë Drag UP = Vibrato | ‚Üì Drag DOWN = Tremolo | 
                ‚Üí Drag to note = Trill | ‚Ä¢ Click = Clear
            </div>
            
            <div class="expression-display" id="expression-display">
                <strong>Current Chord: </strong><span id="chord-display" style="color: #667eea;">None</span>
                <div style="margin-top: 10px;">
                    <strong>Expressions:</strong>
                    <div id="expression-content" style="margin-top: 5px;">
                        <div style="color: #666; font-style: italic;">No expressions set - use drag gestures on piano keys</div>
                    </div>
                </div>
            </div>
        </div>
        
    <div class="section">
        <div class="section-title">Expression Parameters</div>
        <div class="controls">
            <div style="margin-bottom: 15px; padding: 10px; background: #cfe2ff; border-radius: 6px; font-size: 0.9em; color: #0842a0;">
                <strong>Note:</strong> Use drag gestures on the piano above to set expressions for each chord note.
                The parameters below control the behavior when expressions are active.
            </div>
            
            <div class="expression-group vibrato">
                <div class="expression-group-title">Vibrato Parameters</div>
                <div class="control-group">
                    <label for="vibratoRate">Rate</label>
                    <input type="range" id="vibratoRate" value="5.0" min="0.0" max="10.0" step="0.1">
                    <span id="vibratoRateValue" class="value-display">5.0</span>
                </div>
                <div class="control-group">
                    <label for="vibratoDepth">Depth</label>
                    <input type="range" id="vibratoDepth" value="0.0" min="0.0" max="1.0" step="0.01">
                    <span id="vibratoDepthValue" class="value-display">0.00</span>
                </div>
            </div>
            
            <div class="expression-group trill">
                <div class="expression-group-title">Trill Parameters</div>
                <div class="control-group">
                    <label for="trillInterval">Interval</label>
                    <select id="trillInterval">
                        <option value="1">Minor 2nd</option>
                        <option value="2">Major 2nd</option>
                        <option value="3">Minor 3rd</option>
                        <option value="4">Major 3rd</option>
                        <option value="5">Perfect 4th</option>
                        <option value="6">Tritone</option>
                        <option value="7">Perfect 5th</option>
                        <option value="8">Minor 6th</option>
                        <option value="9">Major 6th</option>
                        <option value="10">Minor 7th</option>
                        <option value="11">Major 7th</option>
                        <option value="12">Octave</option>
                    </select>
                    <span id="trillIntervalValue" class="value-display">m2</span>
                </div>
                <div class="control-group">
                    <label for="trillSpeed">Speed</label>
                    <input type="range" id="trillSpeed" value="5.0" min="3.0" max="12.0" step="0.1">
                    <span id="trillSpeedValue" class="value-display">5.0</span>
                </div>
                <div class="control-group">
                    <label for="trillArticulation">Articulation</label>
                    <input type="range" id="trillArticulation" value="0.7" min="0.1" max="0.95" step="0.01">
                    <span id="trillArticulationValue" class="value-display">0.70</span>
                </div>
            </div>
            
            <div class="expression-group tremolo">
                <div class="expression-group-title">Tremolo Parameters</div>
                <div class="control-group">
                    <label for="tremoloSpeed">Speed</label>
                    <input type="range" id="tremoloSpeed" value="4.0" min="1.0" max="12.0" step="0.1">
                    <span id="tremoloSpeedValue" class="value-display">4.0</span>
                </div>
                <div class="control-group">
                    <label for="tremoloDepth">Depth</label>
                    <input type="range" id="tremoloDepth" value="0.7" min="0.0" max="1.0" step="0.01">
                    <span id="tremoloDepthValue" class="value-display">0.70</span>
                </div>
                <div class="control-group">
                    <label for="tremoloArticulation">Articulation</label>
                    <input type="range" id="tremoloArticulation" value="0.5" min="0.01" max="0.99" step="0.01">
                    <span id="tremoloArticulationValue" class="value-display">0.50</span>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
            <div class="section-title">Instrument</div>
            <div class="controls">
                <div class="control-group">
                    <label for="bodyType">Body Type</label>
                    <select id="bodyType">
                        <option value="0">Violin</option>
                        <option value="1">Viola</option>
                        <option value="2">Cello</option>
                        <option value="3">Guitar</option>
                        <option value="4">None</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="stringMaterial">Material</label>
                    <select id="stringMaterial">
                        <option value="0">Steel</option>
                        <option value="1">Gut</option>
                        <option value="2">Nylon</option>
                        <option value="3">Wound</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="stringDamping">Damping</label>
                    <input type="range" id="stringDamping" value="0.5" min="0.01" max="0.99" step="0.01">
                    <span id="stringDampingValue" class="value-display">0.50</span>
                </div>
                <div class="control-group">
                    <label for="brightness">Brightness</label>
                    <input type="range" id="brightness" value="0.5" min="0.0" max="1.0" step="0.01">
                    <span id="brightnessValue" class="value-display">0.50</span>
                </div>
                <div class="control-group">
                    <label for="bodyResonance">Body Resonance</label>
                    <input type="range" id="bodyResonance" value="0.3" min="0.0" max="1.0" step="0.01">
                    <span id="bodyResonanceValue" class="value-display">0.30</span>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Bow Control</div>
            <div class="controls">
                <div class="control-group">
                    <label for="bowForce">Force</label>
                    <input type="range" id="bowForce" value="0.5" min="0.0" max="1.0" step="0.01">
                    <span id="bowForceValue" class="value-display">0.50</span>
                </div>
                <div class="control-group">
                    <label for="bowPosition">Position</label>
                    <input type="range" id="bowPosition" value="0.12" min="0.02" max="0.5" step="0.01">
                    <span id="bowPositionValue" class="value-display">0.12</span>
                </div>
                <div class="control-group">
                    <label for="bowSpeed">Speed</label>
                    <input type="range" id="bowSpeed" value="0.5" min="0.0" max="1.0" step="0.01">
                    <span id="bowSpeedValue" class="value-display">0.50</span>
                </div>
            </div>
        </div>
                
                <div class="expression-group vibrato">
                    <div class="expression-group-title">Vibrato Parameters</div>
                    <div class="control-group">
                        <label for="vibratoRate">Rate</label>
                        <input type="range" id="vibratoRate" value="5.0" min="0.0" max="10.0" step="0.1">
                        <span id="vibratoRateValue" class="value-display">5.0</span>
                    </div>
                    <div class="control-group">
                        <label for="vibratoDepth">Depth</label>
                        <input type="range" id="vibratoDepth" value="0.0" min="0.0" max="1.0" step="0.01">
                        <span id="vibratoDepthValue" class="value-display">0.00</span>
                    </div>
                </div>
                
                <div class="expression-group trill">
                    <div class="expression-group-title">Trill Parameters</div>
                    <div class="control-group">
                        <label for="trillInterval">Interval</label>
                        <select id="trillInterval">
                            <option value="1">Minor 2nd</option>
                            <option value="2">Major 2nd</option>
                            <option value="3">Minor 3rd</option>
                            <option value="4">Major 3rd</option>
                            <option value="5">Perfect 4th</option>
                            <option value="6">Tritone</option>
                            <option value="7">Perfect 5th</option>
                            <option value="8">Minor 6th</option>
                            <option value="9">Major 6th</option>
                            <option value="10">Minor 7th</option>
                            <option value="11">Major 7th</option>
                            <option value="12">Octave</option>
                        </select>
                        <span id="trillIntervalValue" class="value-display">m2</span>
                    </div>
                    <div class="control-group">
                        <label for="trillSpeed">Speed</label>
                        <input type="range" id="trillSpeed" value="5.0" min="3.0" max="12.0" step="0.1">
                        <span id="trillSpeedValue" class="value-display">5.0</span>
                    </div>
                    <div class="control-group">
                        <label for="trillArticulation">Articulation</label>
                        <input type="range" id="trillArticulation" value="0.7" min="0.1" max="0.95" step="0.01">
                        <span id="trillArticulationValue" class="value-display">0.70</span>
                    </div>
                </div>
                
                <div class="expression-group tremolo">
                    <div class="expression-group-title">Tremolo Parameters</div>
                    <div class="control-group">
                        <label for="tremoloSpeed">Speed</label>
                        <input type="range" id="tremoloSpeed" value="4.0" min="1.0" max="12.0" step="0.1">
                        <span id="tremoloSpeedValue" class="value-display">4.0</span>
                    </div>
                    <div class="control-group">
                        <label for="tremoloDepth">Depth</label>
                        <input type="range" id="tremoloDepth" value="0.7" min="0.0" max="1.0" step="0.01">
                        <span id="tremoloDepthValue" class="value-display">0.70</span>
                    </div>
                    <div class="control-group">
                        <label for="tremoloArticulation">Articulation</label>
                        <input type="range" id="tremoloArticulation" value="0.5" min="0.01" max="0.99" step="0.01">
                        <span id="tremoloArticulationValue" class="value-display">0.50</span>
                    </div>
                </div>
            </div>
        </div>



        <hr class="separator">
        
        <div class="section">
            <div class="section-title">Master Output</div>
            <div class="controls">
                <div class="control-group">
                    <label for="masterGain">Volume</label>
                    <input type="range" id="masterGain" value="0.5" min="0.0" max="1.0" step="0.01">
                    <span id="masterGainValue" class="value-display">0.50</span>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="power" checked> Power On/Off
                    </label>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </div>
        
        <hr class="separator">
        
        <div class="section">
            <div class="section-title">Program Banking</div>
            <div class="banking-controls">
                <label for="bank_selector">Bank:</label>
                <select id="bank_selector">
                    <option value="1">Bank 1</option>
                    <option value="2">Bank 2</option>
                    <option value="3">Bank 3</option>
                    <option value="4">Bank 4</option>
                    <option value="5">Bank 5</option>
                </select>
                <button id="save_bank">Save</button>
                <button id="load_bank">Load</button>
            </div>
        </div>
        
        <div id="synths">
            <h3>Connected Synths</h3>
            <div id="synth_list">None connected</div>
        </div>
    </div>

    <script>
        const controller_id = `ctrl-${Math.random().toString(36).substr(2, 9)}`
        const peers = new Map()
        const other_controllers = new Set()
        let ws = null
        let heartbeat_interval = null
        let wake_lock = null
        let kicked = false
        let current_program = create_example_program()
        const program_banks = new Map()
        
        // WebRTC configuration
        let rtc_config = {
            iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
        }
        
        // Fetch ICE servers from server
        async function fetch_ice_servers() {
            try {
                const response = await fetch('/ice-servers')
                const data = await response.json()
                rtc_config.iceServers = data.ice_servers
                console.log('ICE servers loaded:', rtc_config.iceServers)
            } catch (error) {
                console.error('Failed to fetch ICE servers, using defaults:', error)
                // Fall back to default STUN servers
                rtc_config.iceServers = [
                    { urls: "stun:stun.l.google.com:19302" },
                    { urls: "stun:stun1.l.google.com:19302" }
                ]
                console.log('Using default ICE servers:', rtc_config.iceServers)
            }
        }
        
        // UI elements
        const status_el = document.getElementById('status')
        const synth_list_el = document.getElementById('synth_list')
        const connected_count_el = document.getElementById('connected_count')
        const avg_latency_el = document.getElementById('avg_latency')
        
        // Parameter elements
        const param_elements = {}
        const param_ids = [
            'stringMaterial', 'stringDamping',
            'bowPosition', 'bowSpeed', 'bowForce', 'brightness',
            'vibratoRate', 'vibratoDepth', 'trillInterval', 'trillSpeed', 'trillArticulation',
            'tremoloSpeed', 'tremoloDepth', 'tremoloArticulation',
            'bodyType', 'bodyResonance', 'masterGain'
        ]
        
        // Initialize parameter elements
        param_ids.forEach(id => {
            const input = document.getElementById(id)
            const value_display = document.getElementById(id + 'Value')
            if (input && value_display) {
                param_elements[id] = { input, value_display }
            }
        })
        
        // Expression controls
        const expression_radios = document.querySelectorAll('input[name="expression"]')
        const expression_groups = document.querySelectorAll('.expression-group')
        
        // Initialize WebSocket connection
        function connect_websocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'
            const ws_url = `${protocol}//${window.location.host}/`
            
            ws = new WebSocket(ws_url)
            
            ws.addEventListener('open', () => {
                console.log('WebSocket connected')
                status_el.textContent = 'Connected'
                status_el.classList.add('connected')
                
                // Register as controller
                send_message({
                    type: 'register',
                    client_id: controller_id
                })
                
                // Start heartbeat
                heartbeat_interval = setInterval(() => {
                    send_message({ type: 'heartbeat' })
                }, 20000)
            })
            
            ws.addEventListener('message', async (event) => {
                await handle_message(JSON.parse(event.data))
            })
            
            ws.addEventListener('close', () => {
                console.log('WebSocket disconnected')
                status_el.textContent = 'Disconnected'
                status_el.classList.remove('connected')
                
                if (heartbeat_interval) {
                    clearInterval(heartbeat_interval)
                    heartbeat_interval = null
                }
                
                // Reconnect after delay
                setTimeout(connect_websocket, 2000)
            })
            
            ws.addEventListener('error', (error) => {
                console.error('WebSocket error:', error)
            })
        }
        
        function send_message(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message))
            }
        }
        
        async function handle_message(message) {
            if (message.type === 'controllers-list') {
                // Handle controller list (not needed for this client)
            } else if (message.type === 'controller-joined') {
                other_controllers.add(message.controller_id)
                update_controller_warning()
            } else if (message.type === 'controller-left') {
                other_controllers.delete(message.controller_id)
                update_controller_warning()
            } else if (message.type === 'announce') {
                other_controllers.add(message.sender_id)
                update_controller_warning()
            } else if (message.type === 'kicked') {
                kicked = true
                status_el.textContent = `Kicked by ${message.kicked_by}`
                status_el.classList.remove('connected')
            } else if (message.type === 'offer') {
                await handle_offer(message)
            } else if (message.type === 'answer') {
                await handle_answer(message)
            } else if (message.type === 'ice') {
                await handle_ice_candidate(message)
            }
        }
        
        async function handle_offer(message) {
            const synth_id = message.source
            console.log(`Received offer from ${synth_id}`)
            
            const pc = new RTCPeerConnection(rtc_config)
            const peer = {
                connection: pc,
                param_channel: null,
                command_channel: null,
                latency: null,
                last_ping: null,
                state: null
            }
            peers.set(synth_id, peer)
            
            // Handle ICE candidates
            pc.addEventListener('icecandidate', (event) => {
                if (event.candidate) {
                    send_message({
                        type: 'ice',
                        source: controller_id,
                        target: synth_id,
                        data: event.candidate
                    })
                }
            })
            
            // Handle data channels
            pc.addEventListener('datachannel', (event) => {
                const channel = event.channel
                
                if (channel.label === 'params') {
                    peer.param_channel = channel
                    
                    channel.addEventListener('open', () => {
                        console.log(`Param channel open to ${synth_id}`)
                        update_synth_list()
                        
                        // Start ping interval
                        const ping_interval = setInterval(() => {
                            if (channel.readyState === 'open') {
                                const timestamp = Date.now()
                                peer.last_ping = timestamp
                                channel.send(JSON.stringify({
                                    type: 'ping',
                                    timestamp: timestamp
                                }))
                            } else {
                                clearInterval(ping_interval)
                            }
                        }, 1000)
                    })
                    
                    channel.addEventListener('message', (event) => {
                        const data = JSON.parse(event.data)
                        if (data.type === 'pong') {
                            peer.latency = Date.now() - data.timestamp
                            peer.state = data.state || null
                            console.log(`Received pong from ${synth_id} with state:`, data.state)
                            update_synth_list()
                        } else if (data.type === 'request_program') {
                            // send current program to requesting synth
                            console.log(`Received program request from ${synth_id}`)
                            
                            // Note: Frequency is now set per-note via chord distribution
                            
                            console.log('Current program object:', current_program)
                            console.log('Current program has keys:', Object.keys(current_program || {}))
                            if (current_program && Object.keys(current_program).length > 0) {
                                channel.send(JSON.stringify({
                                    type: 'program',
                                    program: current_program
                                }))
                                console.log(`Sent current program to ${synth_id}:`, current_program)
                            } else {
                                console.log(`No program to send to ${synth_id} - creating default program`)
                                const default_program = get_current_program()
                                channel.send(JSON.stringify({
                                    type: 'program',
                                    program: default_program
                                }))
                                console.log(`Sent default program to ${synth_id}:`, default_program)
                            }
                        }
                    })
                    
                    channel.addEventListener('close', () => {
                        console.log(`Param channel closed to ${synth_id}`)
                        update_synth_list()
                    })
                } else if (channel.label === 'commands') {
                    peer.command_channel = channel
                    
                    channel.addEventListener('open', () => {
                        console.log(`Command channel open to ${synth_id}`)
                        update_synth_list()
                    })
                    
                    channel.addEventListener('close', () => {
                        console.log(`Command channel closed to ${synth_id}`)
                        update_synth_list()
                    })
                }
            })
            
            // Set remote description and create answer
            await pc.setRemoteDescription(message.data)
            const answer = await pc.createAnswer()
            await pc.setLocalDescription(answer)
            
            send_message({
                type: 'answer',
                source: controller_id,
                target: synth_id,
                data: answer
            })
        }
        
        async function handle_answer(message) {
            // Controllers don't initiate connections, so this shouldn't happen
            console.warn('Received unexpected answer message')
        }
        
        async function handle_ice_candidate(message) {
            const synth_id = message.source
            const peer = peers.get(synth_id)
            
            if (peer && peer.connection) {
                await peer.connection.addIceCandidate(message.data)
            }
        }
        
        function update_synth_list() {
            const synth_entries = Array.from(peers.entries())
            connected_count_el.textContent = synth_entries.filter(([id, peer]) => 
                peer.param_channel && peer.param_channel.readyState === 'open'
            ).length.toString()
            
            if (synth_entries.length === 0) {
                synth_list_el.innerHTML = "None connected"
            } else {
                synth_list_el.innerHTML = synth_entries.map(([id, peer]) => {
                    const param_state = peer.param_channel ? peer.param_channel.readyState : 'closed'
                    const command_state = peer.command_channel ? peer.command_channel.readyState : 'closed'
                    const connection_state = (param_state === 'open' && command_state === 'open') ? 'connected' : 
                                 (param_state === 'connecting' || command_state === 'connecting') ? 'connecting' : 'disconnected'
                    
                    const latency_text = peer.latency !== null ? `<span class="latency">${peer.latency}ms</span>` : ""
                    
                    // Build detailed state information
                    let state_details = ""
                    if (peer.state) {
                        const audio_status = peer.state.audio_enabled ? 'running' : 'disabled'
                        const synthesis_status = peer.state.joined ? 'joined' : 'calibrating'
                        
                        state_details = `
                            <div class="synth-details">
                                <span class="audio-state">Audio: ${audio_status}</span>
                                <span class="synthesis-state">Synth: ${synthesis_status}</span>
                            </div>`
                    }
                    
                    return `<div class="synth ${connection_state}">
                        <div class="synth-header">${id} [${connection_state}] ${latency_text}</div>
                        ${state_details}
                    </div>`
                }).join("")
            }
            
            // Update average latency
            const latencies = synth_entries.map(([id, peer]) => peer.latency).filter(l => l !== null)
            if (latencies.length > 0) {
                const avg = Math.round(latencies.reduce((a, b) => a + b, 0) / latencies.length)
                avg_latency_el.textContent = `${avg}ms`
            } else {
                avg_latency_el.textContent = '-'
            }
        }
        
        // Send program to all connected synths
        function send_program(program) {
            current_program = program
            peers.forEach((peer, id) => {
                if (peer.param_channel && peer.param_channel.readyState === 'open') {
                    peer.param_channel.send(JSON.stringify({
                        type: 'program',
                        program: program
                    }))
                }
            })
            console.log(`Sent program with ${Object.keys(program).length} parameters`)
        }
        
        // Get current program from UI
        function get_current_program() {
            const program = {}
            
            param_ids.forEach(id => {
                // Skip frequency since it's now set per-note in chord distribution
                if (id === 'frequency') return
                
                const element = param_elements[id]
                if (element && element.input) {
                    const value = element.input.type === 'range' ? 
                        parseFloat(element.input.value) : 
                        element.input.value
                    program[id] = value
                }
            })
            
            // Note: Expression is now handled per-note via drag gestures
            // Global expression parameters are still included for each expression type
            
            return program
        }
        
        // Create example program with stochastic elements
        function create_example_program() {
            return {
                stringMaterial: { type: "choice", options: [0, 1, 2, 3] },
                stringDamping: { type: "uniform", min: 0.3, max: 0.7 },
                bowPosition: { type: "uniform", min: 0.08, max: 0.25 },
                bowSpeed: { type: "normal", mean: 0.6, std: 0.1 },
                bowForce: { type: "uniform", min: 0.3, max: 0.8 },
                brightness: { type: "uniform", min: 0.2, max: 0.8 },
                vibratoRate: { type: "uniform", min: 4.0, max: 7.0 },
                vibratoDepth: { type: "uniform", min: 0.0, max: 0.3 },
                bodyType: { type: "choice", options: [0, 1, 2] },
                bodyResonance: { type: "uniform", min: 0.1, max: 0.6 },
                masterGain: 0.5
            }
        }
        
        // Save program to bank
        function save_to_bank(bank_id) {
            program_banks.set(bank_id, current_program)
            peers.forEach((peer, id) => {
                if (peer.command_channel && peer.command_channel.readyState === 'open') {
                    peer.command_channel.send(JSON.stringify({
                        type: 'command',
                        name: 'save',
                        value: bank_id
                    }))
                }
            })
            console.log(`Saved program to bank ${bank_id}`)
        }
        
        // Load program from bank
        function load_from_bank(bank_id) {
            if (program_banks.has(bank_id)) {
                const saved_program = program_banks.get(bank_id)
                peers.forEach((peer, id) => {
                    if (peer.command_channel && peer.command_channel.readyState === 'open') {
                        peer.command_channel.send(JSON.stringify({
                            type: 'command',
                            name: 'load',
                            bank: bank_id,
                            program: saved_program
                        }))
                    }
                })
                console.log(`Loaded program from bank ${bank_id}`)
            } else {
                console.warn(`Bank ${bank_id} not found`)
            }
        }
        
        // Update UI display values
        function update_display_value(id, value) {
            const element = param_elements[id]
            if (element && element.value_display) {
                if (id === 'stringMaterial') {
                    const materials = ['Steel', 'Gut', 'Nylon', 'Wound']
                    element.value_display.textContent = materials[value] || materials[0]
                } else if (id === 'bodyType') {
                    const bodies = ['Violin', 'Viola', 'Cello', 'Guitar', 'None']
                    element.value_display.textContent = bodies[value] || bodies[0]
                } else if (id === 'trillInterval') {
                    const intervals = ['m2', 'M2', 'm3', 'M3', 'P4', 'TT', 'P5', 'm6', 'M6', 'm7', 'M7', '8va']
                    element.value_display.textContent = intervals[value - 1] || 'm2'
                } else if (typeof value === 'number') {
                    const decimals = value < 1 ? 2 : (value < 10 ? 1 : 0)
                    element.value_display.textContent = value.toFixed(decimals)
                } else {
                    element.value_display.textContent = value.toString()
                }
            }
        }
        
        // Update expression group visibility
        function update_expression_groups() {
            const expressionRadio = document.querySelector('input[name="expression"]:checked')
            if (!expressionRadio) {
                console.log('Expression radio buttons not found yet')
                return
            }
            
            const active_expression = expressionRadio.value
            expression_groups.forEach(group => {
                group.classList.remove('active')
            })
            
            if (active_expression !== 'none') {
                const active_group = document.querySelector(`.expression-group.${active_expression}`)
                if (active_group) {
                    active_group.classList.add('active')
                }
            }
        }
        
        function update_controller_warning() {
            const warning_el = document.getElementById('controller_warning')
            const other_controllers_el = document.getElementById('other_controllers')
            
            if (other_controllers.size > 0) {
                warning_el.classList.add('show')
                other_controllers_el.textContent = `Other controllers: ${Array.from(other_controllers).join(', ')}`
            } else {
                warning_el.classList.remove('show')
            }
        }
        
        // Event Listeners
        
        // Parameter input handlers (combined with change tracking)
        param_ids.forEach(id => {
            const element = param_elements[id]
            if (element && element.input) {
                element.input.addEventListener('input', (e) => {
                    const value = e.target.type === 'range' ? parseFloat(e.target.value) : e.target.value
                    update_display_value(id, value)
                    console.log('Combined input event fired for', id, 'new value:', value)
                    mark_parameter_changed(id)
                    check_overall_status()
                })
            }
        })
        
        // Expression radio handlers
        expression_radios.forEach(radio => {
            radio.addEventListener('change', update_expression_groups)
        })
        
        // Program control buttons
        document.getElementById('send_current_program').addEventListener('click', () => {
            update_status_badge('sending')
            const program = get_current_program()
            send_program(program)
            mark_all_parameters_sent()
            setTimeout(() => update_status_badge('synced'), 500)
        })
        
        // Banking controls
        document.getElementById('save_bank').addEventListener('click', () => {
            const bank_id = parseInt(document.getElementById('bank_selector').value)
            save_to_bank(bank_id)
        })
        
        document.getElementById('load_bank').addEventListener('click', () => {
            const bank_id = parseInt(document.getElementById('bank_selector').value)
            load_from_bank(bank_id)
        })
        
        // Power control
        document.getElementById('power').addEventListener('change', (e) => {
            const is_on = e.target.checked
            peers.forEach((peer, id) => {
                if (peer.command_channel && peer.command_channel.readyState === 'open') {
                    peer.command_channel.send(JSON.stringify({
                        type: 'command',
                        name: 'power',
                        value: is_on
                    }))
                }
            })
        })
        
        // Kick other controllers
        document.getElementById('kick_others').addEventListener('click', () => {
            send_message({
                type: 'kick-other-controllers'
            })
            other_controllers.clear()
            update_controller_warning()
        })
        
        // Initialize UI
        function initialize_ui() {
            // Set initial display values
            param_ids.forEach(id => {
                const element = param_elements[id]
                if (element && element.input) {
                    const value = element.input.type === 'range' ? 
                        parseFloat(element.input.value) : 
                        element.input.value
                    update_display_value(id, value)
                }
            })
            
            // Initialize expression groups
            update_expression_groups()
        
            // Initialize piano GUI
            initialize_piano()
            
            // Initialize parameter change tracking
            initialize_parameter_tracking()
        }

        // Piano GUI functions
        function calculate_ranges() {
            return {
                0: { name: 'Violin', low: note_to_frequency('G', 3), high: note_to_frequency('A', 7) },     // G3 to A7
                1: { name: 'Viola', low: note_to_frequency('C', 3), high: note_to_frequency('E', 6) },     // C3 to E6
                2: { name: 'Cello', low: note_to_frequency('C', 2), high: note_to_frequency('C', 6) },     // C2 to C6
                3: { name: 'Guitar', low: note_to_frequency('E', 3), high: note_to_frequency('E', 6) },    // E3 to E6
                4: { name: 'None', low: note_to_frequency('A', 1), high: note_to_frequency('C', 8) }       // A1 to C8
            }
        }
        
        const instrument_ranges = calculate_ranges()

        function note_to_frequency(note, octave) {
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
            // A4 = 440Hz is note number 69 in MIDI (A4 = 4*12 + 9 = 57, but we need A4=69)
            // Calculate semitones from A4
            const note_index = notes.indexOf(note)
            const semitones_from_a4 = (octave - 4) * 12 + (note_index - 9)
            return 440 * Math.pow(2, semitones_from_a4 / 12)
        }

        function frequency_to_note(freq) {
            // Calculate semitones from A4 (440Hz)
            const semitones_from_a4 = Math.round(12 * Math.log2(freq / 440))
            
            // A4 is octave 4, note index 9 (A)
            const total_semitones = semitones_from_a4 + (4 * 12) + 9
            const octave = Math.floor(total_semitones / 12)
            const note_index = ((total_semitones % 12) + 12) % 12
            
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']
            return { note: notes[note_index], octave: octave }
        }

        function initialize_piano() {
            const piano = document.getElementById('piano')
            const bodyType = parseInt(document.getElementById('bodyType').value)
            draw_piano_keys(bodyType)
            update_piano_range_display(bodyType)
        
            // Update piano when body type changes
            document.getElementById('bodyType').addEventListener('change', (e) => {
                const newBodyType = parseInt(e.target.value)
                draw_piano_keys(newBodyType)
                update_piano_range_display(newBodyType)
            })
        }

        function draw_piano_keys(bodyType) {
            const piano = document.getElementById('piano')
            const range = instrument_ranges[bodyType]
            
            console.log('Drawing piano keys for bodyType:', bodyType, 'range:', range)
            
            // Debug: Test a few known frequencies
            console.log('Test frequencies:')
            console.log('G3 (violin low):', note_to_frequency('G', 3), 'expected: 196, in range?', note_to_frequency('G', 3) >= range.low && note_to_frequency('G', 3) <= range.high)
            console.log('F#3 (below violin):', note_to_frequency('F#', 3), 'in range?', note_to_frequency('F#', 3) >= range.low && note_to_frequency('F#', 3) <= range.high)
            console.log('A4 (440Hz):', note_to_frequency('A', 4), 'in range?', note_to_frequency('A', 4) >= range.low && note_to_frequency('A', 4) <= range.high)
            console.log('Range:', range.low, 'to', range.high)
            
            // Clear existing keys
            piano.innerHTML = ''
            
            // Define full piano range
            const start_octave = 2
            const end_octave = 7
            const white_keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B']
            const key_width = 16
            const white_key_height = 60
            const black_key_height = 35
            
            let key_count = 0
            let white_key_x = 0
            
            // Draw white keys first
            for (let octave = start_octave; octave <= end_octave; octave++) {
                for (let note of white_keys) {
                    const freq = note_to_frequency(note, octave)
                    const in_range = freq >= range.low && freq <= range.high
                    
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
                    rect.setAttribute('x', white_key_x)
                    rect.setAttribute('y', 10)
                    rect.setAttribute('width', key_width)
                    rect.setAttribute('height', white_key_height)
                    rect.setAttribute('fill', in_range ? 'white' : '#f5f5f5')
                    rect.setAttribute('stroke', '#333')
                    rect.setAttribute('stroke-width', '1')
                    rect.setAttribute('data-note', note)
                    rect.setAttribute('data-octave', octave)
                    rect.setAttribute('data-freq', freq.toFixed(1))
                    
                    if (in_range) {
                        rect.style.cursor = 'pointer'
                        rect.addEventListener('click', () => select_frequency(freq))
                        rect.addEventListener('mouseenter', () => {
                            // Don't change hover color if it's managed by SVG expression system
                            if (!rect.hasAttribute('data-original-fill')) {
                                rect.setAttribute('fill', '#e6f3ff')
                            }
                        })
                        rect.addEventListener('mouseleave', () => {
                            // Don't change hover color if it's managed by SVG expression system
                            if (!rect.hasAttribute('data-original-fill')) {
                                rect.setAttribute('fill', 'white')
                            }
                        })
                    }
                    
                    piano.appendChild(rect)
                    key_count++
                    white_key_x += key_width
                }
            }
            
            // Draw black keys on top
            white_key_x = 0
            for (let octave = start_octave; octave <= end_octave; octave++) {
                for (let i = 0; i < white_keys.length; i++) {
                    const note = white_keys[i]
                    
                    // Check if there's a black key after this white key
                    let black_note = null
                    if (note === 'C') black_note = 'C#'
                    else if (note === 'D') black_note = 'D#'
                    else if (note === 'F') black_note = 'F#'
                    else if (note === 'G') black_note = 'G#'
                    else if (note === 'A') black_note = 'A#'
                    
                    if (black_note) {
                        const freq = note_to_frequency(black_note, octave)
                        const in_range = freq >= range.low && freq <= range.high
                        
                        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect')
                        rect.setAttribute('x', white_key_x + key_width - 6)
                        rect.setAttribute('y', 10)
                        rect.setAttribute('width', 12)
                        rect.setAttribute('height', black_key_height)
                        rect.setAttribute('fill', in_range ? '#333' : '#ccc')
                        rect.setAttribute('stroke', '#000')
                        rect.setAttribute('stroke-width', '1')
                        rect.setAttribute('data-note', black_note)
                        rect.setAttribute('data-octave', octave)
                        rect.setAttribute('data-freq', freq.toFixed(1))
                        
                        if (in_range) {
                            rect.style.cursor = 'pointer'
                            rect.addEventListener('click', () => select_frequency(freq))
                            rect.addEventListener('mouseenter', () => {
                                // Don't change hover color if it's managed by SVG expression system
                                if (!rect.hasAttribute('data-original-fill')) {
                                    rect.setAttribute('fill', '#555')
                                }
                            })
                            rect.addEventListener('mouseleave', () => {
                                // Don't change hover color if it's managed by SVG expression system
                                if (!rect.hasAttribute('data-original-fill')) {
                                    rect.setAttribute('fill', '#333')
                                }
                            })
                        }
                        
                        piano.appendChild(rect)
                        key_count++
                    }
                    
                    white_key_x += key_width
                }
            }
            
            console.log('Created', key_count, 'piano keys')
            document.getElementById('piano-debug').textContent = `Debug: Created ${key_count} keys`
            
            // Highlight current frequency
            setTimeout(() => highlight_current_frequency(), 100)
            
            // Try to initialize SVG expression now that piano is ready
            if (typeof initializeSVGExpression === 'function') {
                initializeSVGExpression();
            }
        }

        function update_piano_range_display(bodyType) {
            const range = instrument_ranges[bodyType]
            const low_note = frequency_to_note(range.low)
            const high_note = frequency_to_note(range.high)
            console.log('Range display - low freq:', range.low, 'high freq:', range.high)
            console.log('Range display - low note:', low_note, 'high note:', high_note)
            document.getElementById('piano-range-display').textContent = 
                `Range: ${low_note.note}${low_note.octave}-${high_note.note}${high_note.octave} (${range.name})`
        }

        function select_frequency(freq) {
            // Find the note name from frequency
            const noteData = frequency_to_note(freq);
            const noteName = `${noteData.note}${noteData.octave}`;
            
            console.log('Piano key clicked:', noteName, freq);
            
            // Let the expression system handle chord membership
            // It will trigger handleExpressionChange which will sync the chord
            console.log('Piano key clicked, letting expression system handle:', noteName);
            
            console.log('Current chord:', currentChord);
            
            // Update chord display with trill targets in brackets
            const chordDisplay = document.getElementById('chord-display');
            if (chordDisplay && svgExpression) {
                if (currentChord.length > 0) {
                    const expressions = svgExpression.getAllExpressions();
                    const processedNotes = new Set();
                    const chordParts = [];
                    
                    currentChord.forEach(note => {
                        if (processedNotes.has(note)) return;
                        
                        const expr = expressions[note];
                        if (expr && expr.type === 'trill' && expr.targetNote) {
                            // Show trill with target in brackets
                            chordParts.push(`${note} (‚Üí${expr.targetNote})`);
                            processedNotes.add(note);
                            processedNotes.add(expr.targetNote);
                        } else {
                            // Check if this is a trill target
                            let isTrillTarget = false;
                            for (const [otherNote, otherExpr] of Object.entries(expressions)) {
                                if (otherExpr && otherExpr.type === 'trill' && otherExpr.targetNote === note) {
                                    isTrillTarget = true;
                                    break;
                                }
                            }
                            if (!isTrillTarget) {
                                chordParts.push(note);
                                processedNotes.add(note);
                            }
                        }
                    });
                    
                    chordDisplay.textContent = chordParts.join(' ');
                } else {
                    chordDisplay.textContent = 'None';
                }
            }
            
            // Update SVG expression system
            if (svgExpression) {
                console.log('Updating SVG expression system with chord notes');
                svgExpression.setChordNotes(currentChord);
                
                // Force a re-render
                setTimeout(() => {
                    svgExpression.render();
                }, 10);
            } else {
                console.log('Warning: svgExpression not initialized yet - will update when ready');
                // Store chord for when expression system is ready
                window.pendingChordUpdate = currentChord;
            }
            updateExpressionDisplay();
        }

        function highlight_current_frequency() {
            // Note: This function is no longer used since frequency is set per-note
            // Kept for compatibility but does nothing
            return;
        }

        // Start the application
        async function start_controller() {
            await fetch_ice_servers()
            initialize_ui()
            connect_websocket()
        }

        // Parameter change tracking
        let sent_program_state = {}
        
        function initialize_parameter_tracking() {
            // Store initial state as "sent"
            sent_program_state = get_current_program()
            update_status_badge('synced')
            
            // Add listeners to expression radios (parameters already handled above)
            document.querySelectorAll('input[name="expression"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    console.log('Expression radio changed to:', radio.value)
                    mark_parameter_changed('expression')
                    check_overall_status()
                })
            })
        }
        
        function mark_parameter_changed(param_id) {
            console.log('Marking parameter changed:', param_id)
            
            // Find the control group for this parameter
            let control_group = null
            
            if (param_id === 'expression') {
                control_group = document.querySelector('input[name="expression"]').closest('.control-group')
            } else {
                const element = param_elements[param_id]
                if (element && element.input) {
                    control_group = element.input.closest('.control-group')
                }
            }
            
            if (control_group) {
                control_group.classList.remove('sent')
                control_group.classList.add('changed')
                console.log('Added changed class to', param_id)
            } else {
                console.log('Could not find control group for', param_id)
            }
        }
        
        function mark_all_parameters_sent() {
            // Remove changed class and briefly add sent class to all parameters
            param_ids.forEach(id => {
                const element = param_elements[id]
                if (element && element.input) {
                    const control_group = element.input.closest('.control-group')
                    if (control_group) {
                        control_group.classList.remove('changed')
                        control_group.classList.add('sent')
                        setTimeout(() => {
                            control_group.classList.remove('sent')
                        }, 1000)
                    }
                }
            })
            
            // Handle expression group
            const expressionGroup = document.querySelector('input[name="expression"]').closest('.control-group')
            if (expressionGroup) {
                expressionGroup.classList.remove('changed')
                expressionGroup.classList.add('sent')
                setTimeout(() => {
                    expressionGroup.classList.remove('sent')
                }, 1000)
            }
            
            // Update sent state
            sent_program_state = get_current_program()
        }
        
        function check_overall_status() {
            const current_state = get_current_program()
            const has_changes = JSON.stringify(current_state) !== JSON.stringify(sent_program_state)
            
            if (has_changes) {
                update_status_badge('pending')
            } else {
                update_status_badge('synced')
            }
        }
        
        function update_status_badge(status) {
            const badge = document.getElementById('status_badge')
            badge.className = `status-badge ${status}`
            
            switch(status) {
                case 'synced':
                    badge.textContent = '‚úì Synced'
                    break
                case 'pending':
                    badge.textContent = '‚óè Changes Pending'
                    break
                case 'sending':
                    badge.textContent = 'üì° Sending...'
                    break
            }
        }

        // Start when page loads
        start_controller()
    </script>
    
    <!-- Include interactive expression and stochastic chord modules -->
    <script src="svg_interactive_expression.js"></script>
    <script src="stochastic_chords.js"></script>
    <script src="standard_parameters.js"></script>
    
    <script>
        // Initialize chord and expression system
        let svgExpression = null;
        let chordDistributor = new StochasticChordDistributor();
        let currentChord = [];
        
        // Initialize SVG interactive expression when piano is ready
        function initializeSVGExpression() {
            const piano = document.getElementById('piano');
            if (piano && piano.querySelectorAll('rect').length > 0) {
                svgExpression = new SVGInteractiveExpression(piano);
                svgExpression.onExpressionChange = handleExpressionChange;
                console.log('SVG Interactive expression system initialized');
                
                // If chord already exists, update the expression system
                if (currentChord.length > 0) {
                    svgExpression.setChordNotes(currentChord);
                }
                
                // Check for pending chord update
                if (window.pendingChordUpdate) {
                    svgExpression.setChordNotes(window.pendingChordUpdate);
                    delete window.pendingChordUpdate;
                }
                return true;
            }
            return false;
        }
        
        // Try to initialize immediately, then retry if needed
        if (!initializeSVGExpression()) {
            const initInterval = setInterval(() => {
                if (initializeSVGExpression()) {
                    clearInterval(initInterval);
                }
            }, 100);
        }
        
        function handleExpressionChange(note, expression) {
            console.log('Expression change:', note, expression);
            
            // Sync chord array with expression system
            if (svgExpression) {
                const chordNotes = svgExpression.getChordNotes();
                currentChord = chordNotes.sort((a, b) => {
                    const freqA = note_to_frequency(a.slice(0, -1), parseInt(a.slice(-1)));
                    const freqB = note_to_frequency(b.slice(0, -1), parseInt(b.slice(-1)));
                    return freqA - freqB;
                });
                console.log('Updated chord from expression system:', currentChord);
            }
            
            updateExpressionDisplay();
        }
        
        function updateExpressionDisplay() {
            const content = document.getElementById('expression-content');
            const chordDisplay = document.getElementById('chord-display');
            if (!content) return;
            
            // Update chord display with trill targets in brackets
            if (chordDisplay) {
                if (currentChord.length > 0) {
                    const expressions = svgExpression ? svgExpression.getAllExpressions() : {};
                    const processedNotes = new Set();
                    const chordParts = [];
                    
                    currentChord.forEach(note => {
                        if (processedNotes.has(note)) return;
                        
                        const expr = expressions[note];
                        if (expr && expr.type === 'trill' && expr.targetNote) {
                            // Show trill with target in brackets
                            chordParts.push(`${note} (‚Üí${expr.targetNote})`);
                            processedNotes.add(note);
                            processedNotes.add(expr.targetNote);
                        } else {
                            // Check if this is a trill target
                            let isTrillTarget = false;
                            for (const [otherNote, otherExpr] of Object.entries(expressions)) {
                                if (otherExpr && otherExpr.type === 'trill' && otherExpr.targetNote === note) {
                                    isTrillTarget = true;
                                    break;
                                }
                            }
                            if (!isTrillTarget) {
                                chordParts.push(note);
                                processedNotes.add(note);
                            }
                        }
                    });
                    
                    chordDisplay.textContent = chordParts.join(' ');
                } else {
                    chordDisplay.textContent = 'None';
                }
            }
            
            if (!svgExpression) {
                content.innerHTML = '<div style="color: #666; font-style: italic;">Loading expression system...</div>';
                return;
            }
            
            const expressions = svgExpression.getAllExpressions();
            const activeExpressions = Object.entries(expressions);
            
            if (activeExpressions.length === 0) {
                content.innerHTML = '<div style="color: #666; font-style: italic;">Click piano keys to add notes to chord</div>';
                return;
            }
            
            // Group notes by trill relationships
            const processedNotes = new Set();
            const displayItems = [];
            
            activeExpressions.forEach(([note, expression]) => {
                if (processedNotes.has(note)) return;
                
                let exprText = '';
                let className = 'note-expression';
                
                switch (expression.type) {
                    case 'vibrato':
                        exprText = `${note}: Vibrato (depth: ${(expression.depth * 100).toFixed(0)}%)`;
                        className += ' vibrato';
                        break;
                    case 'tremolo':
                        exprText = `${note}: Tremolo (depth: ${(expression.depth * 100).toFixed(0)}%)`;
                        className += ' tremolo';
                        break;
                    case 'trill':
                        exprText = `${note}: Trill`;
                        className += ' trill';
                        // Add trill target in brackets with styled arrow
                        if (expression.targetNote) {
                            exprText += ` <span style="opacity: 0.7; font-size: 0.9em;">(‚Üí ${expression.targetNote})</span>`;
                            processedNotes.add(expression.targetNote);
                        }
                        break;
                    default:
                        // Check if this note is a trill target for another note
                        let isTrillTarget = false;
                        for (const [otherNote, otherExpr] of activeExpressions) {
                            if (otherExpr.type === 'trill' && otherExpr.targetNote === note) {
                                isTrillTarget = true;
                                break;
                            }
                        }
                        if (!isTrillTarget) {
                            exprText = `${note}`;
                            className += ' none';
                        }
                        break;
                }
                
                if (exprText) {
                    displayItems.push(`<div class="${className}">${exprText}</div>`);
                }
                processedNotes.add(note);
            });
            
            content.innerHTML = displayItems.join('');
        }
        

        

    </script>
</body>
</html>